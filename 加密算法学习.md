

# 密码学学习

**2020.10.14**

***

## SHA256 算法原理及介绍 

### SHA-2 族算法简介

* 一个`n`位的哈希函数就是一个从任意长的消息到`n`位哈希值的映射，一个`n`位的加密哈希函数就是一个单向的、避免碰撞的`n`位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。

### SHA256原理详解

#### 简介

* 对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。
* 例子：`blockchain` 的SHA-256具有如下哈希值
* `3a6fed5fc11392b3ee9f81caf017b48640d7458766a8eb0382899a605b41f2b9`
* 总体上，HSA256与MD4、MD5以及HSA-1等哈希函数的操作流程类似，待哈希的消息在继续哈希计算之前首先要进行以下两个步骤：
* 对消息进行补位处理，是的最终的长度是512位的倍数，然后
* 以512位为单位对消息进行分块为![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D)
* 消息区块将进行逐个处理：从一个固定的初始哈希![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)开始，进行以下序列的计算：
* ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D%3DH%5E%7B%28i-1%29%7D%2BC_%7BM%5E%7B%28i%29%7D+%7D%28H%5E%7B%28i-1%29%7D%29+%5C%5C)

#### 常量初始化

* 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位

* ![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7B2%7D)小数部分约为0.414213562373095048

* ![[公式]](https://www.zhihu.com/equation?tex=0.414213562373095048+%5Capprox+6%2A16%5E%7B-1%7D%2Ba%2A16%5E%7B-2%7D%2B0%2A16%5E%7B-3%7D%2B...+%5C%5C)

* 于是, 质数2的平方根的小数部分取前32位就对应`0x6a09e667`

* 如此类推, 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)由以下8个32位的哈希初值构成:

  ![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%280%29%7D_1%26%3D6a09e667%5C%5C+H%5E%7B%280%29%7D_2%26%3Dbb67ae85%5C%5C+H%5E%7B%280%29%7D_3%26%3D3c6ef372%5C%5C+H%5E%7B%280%29%7D_4%26%3Da54ff53a%5C%5C+H%5E%7B%280%29%7D_5%26%3D510e527f%5C%5C+H%5E%7B%280%29%7D_6%26%3D9b05688c%5C%5C+H%5E%7B%280%29%7D_7%26%3D1f83d9ab%5C%5C+H%5E%7B%280%29%7D_8%26%3D5be0cd19+%5Cend%7Balign%7D+%5C%5C)

* SHA256算法当中还使用到64个常数, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下

* ```text
  428a2f98 71374491 b5c0fbcf e9b5dba5
  3956c25b 59f111f1 923f82a4 ab1c5ed5
  d807aa98 12835b01 243185be 550c7dc3
  72be5d74 80deb1fe 9bdc06a7 c19bf174
  e49b69c1 efbe4786 0fc19dc6 240ca1cc
  2de92c6f 4a7484aa 5cb0a9dc 76f988da
  983e5152 a831c66d b00327c8 bf597fc7
  c6e00bf3 d5a79147 06ca6351 14292967
  27b70a85 2e1b2138 4d2c6dfc 53380d13
  650a7354 766a0abb 81c2c92e 92722c85
  a2bfe8a1 a81a664b c24b8b70 c76c51a3
  d192e819 d6990624 f40e3585 106aa070
  19a4c116 1e376c08 2748774c 34b0bcb5
  391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
  748f82ee 78a5636f 84c87814 8cc70208
  90befffa a4506ceb bef9a3f7 c67178f2
  ```

#### 消息预处理

* 在计算消息的哈希摘要之前需要对消息进行预处理:

* 对消息进行补码处理: 假设消息![[公式]](https://www.zhihu.com/equation?tex=M)的二进制编码长度为![[公式]](https://www.zhihu.com/equation?tex=l)位. 首先在消息末尾补上一位"1", 然后再补上![[公式]](https://www.zhihu.com/equation?tex=k)个"0", 其中![[公式]](https://www.zhihu.com/equation?tex=k)为下列方程的最小非负整数

* ![[公式]](https://www.zhihu.com/equation?tex=l%2B1%2Bk%5Cequiv448%5Cmod+512+%5C%5C)

* 举个例子, 以消息"abc"为例显示补位的过程.

  a,b,c对应的**[ASCII码](https://link.zhihu.com/?target=http%3A//ascii.911cha.com/)**和二进制编码分别如下:

  ```text
  原始字符    ASCII码    二进制编码
  a          97         01100001
  b          98         01100010
  c          99         01100011
  ```

* 因此, 原始信息"abc"的二进制编码为:`01100001 01100010 01100011`, 第一步补位, 首先在消息末尾补上一位"1", 结果为: `01100001 01100010 01100011 1`; 然后进行第二步的补位, 因为![[公式]](https://www.zhihu.com/equation?tex=l%3D24), 可以得到![[公式]](https://www.zhihu.com/equation?tex=k%3D423), 在第一步补位后的消息后面再补423个"0", 结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D+%5C%5C)

* 最后还需要在上述字节串后面继续进行补码, 这个时候补的是原消息"abc"的二进制长度![[公式]](https://www.zhihu.com/equation?tex=l%3D24)的64位二进制表示形式, 补完以后的结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D%5C%2C%5Cunderbrace%7B00...011000%7D_%7B64%7D+%5C%5C)

* 最终补完以后的消息二进制位数长度是512的倍数

* 这里需要注意的两点是不管原来的消息长度是多少, 即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位. 另外, 考虑到最后要将消息长度![[公式]](https://www.zhihu.com/equation?tex=l)转换为64位二进制编码, 因此, 长度的必须小于![[公式]](https://www.zhihu.com/equation?tex=2%5E%7B64%7D), 绝大多数情况, 这个足够大了

* 将补码处理后的消息以512位为单位分块为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D), 其中第![[公式]](https://www.zhihu.com/equation?tex=i)个消息块的前32位表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_0), 后面32位为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_1), 以此类推, 最后32位的消息块可表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_%7B15%7D). 我们采用Big endian约定对数据进行编码, 即认为第一个字节是最高位字节, 因此, 对于每一个32位字节, 最最左边的比特是最大的比特位

#### 摘要计算主循环

哈希计算算法如下:

- ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+i+%3D+1+%5Cto+N) (![[公式]](https://www.zhihu.com/equation?tex=N) = 补码后消息块个数)

- - 用第![[公式]](https://www.zhihu.com/equation?tex=+%28i+-+1%29)个中间哈希值来对 ![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc%2Cd%2Ce%2Cf%2Cg%2Ch)进行初始化, 当![[公式]](https://www.zhihu.com/equation?tex=i%3D1)时, 就使用初始化哈希, 即:

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+a%26%5Cgets+H%5E%7B%28i-1%29%7D_1%5C%5C+b%26%5Cgets+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+h%26%5Cgets+H%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- 应用SHA256压缩函数来更新![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2C...%2Ch)

- - ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+j+%3D+0+%5Cto+63)

  - - 计算![[公式]](https://www.zhihu.com/equation?tex=Ch%28e%2Cf%2Cg%29%2C+M_%7Baj%7D%28a%2Cb%2Cc%29%2C+%5CSigma_0%28a%29%2C+%5CSigma_1%28e%29%2C+W_j)(具体定义如下)
    - PS：对于每一块M，将块分解为16个32-bit的big-endian的字，记为w[0], …, w[15]，其余的字由如下迭代公式得到：
    - ![[公式]](https://www.zhihu.com/equation?tex=W_j%5Cgets+%5Csigma_1%28W_%7Bj-2%7D%29%2BW_%7Bj-7%7D%2B%5Csigma_0%28W_%7Bj-15%7D%29%2BW_%7Bj-16%7D)
    - 进行下面运算

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+T_1+%26%5Cgets+h%2B%5CSigma_1%28e%29%2BCh%28e%2Cf%2Cg%29%2BK_j%2BW_j%5C%5C+T_2%26%5Cgets+%5CSigma_0%28a%29%2BM_%7Baj%7D%28a%2Cb%2Cc%29%5C%5C+h%26%5Cgets+g%5C%5C+g%26%5Cgets+f%5C%5C+f%26%5Cgets+e%5C%5C+e%26%5Cgets+d%2BT_1%5C%5C+d%26%5Cgets+c%5C%5C+c%26%5Cgets+b%5C%5C+b%26%5Cgets+a%5C%5C+a%26%5Cgets+T_1%2BT_2+%5Cend%7Balign%7D+%5C%5C)

- 计算第![[公式]](https://www.zhihu.com/equation?tex=i)个中间哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D)

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%28i%29%7D_1+%26%5Cgets+a+%2B+H%5E%7B%28i-1%29%7D_1%5C%5C+H%5E%7B%28i%29%7D_2+%26%5Cgets+b%2B+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+H%5E%7B%28i%29%7D_8+%26%5Cgets+h%2BH%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28N%29%7D%3D%28H%5E%7B%28N%29%7D_1%2CH%5E%7B%28N%29%7D_2%2C...%2CH%5E%7B%28N%29%7D_8%29)为最终需要的哈希![[公式]](https://www.zhihu.com/equation?tex=M)。



### SHA伪代码

```text
Note 1: All variables are 32 bit unsigned integers and addition is calculated modulo 232
Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 ≤ i ≤ 63
Note 3: The compression function uses 8 working variables, a through h
Note 4: Big-endian convention is used when expressing the constants in this pseudocode,
    and when parsing message block data from bytes to words, for example,
    the first word of the input message "abc" after padding is 0x61626380

Initialize hash values:
(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
h0 := 0x6a09e667
h1 := 0xbb67ae85
h2 := 0x3c6ef372
h3 := 0xa54ff53a
h4 := 0x510e527f
h5 := 0x9b05688c
h6 := 0x1f83d9ab
h7 := 0x5be0cd19

Initialize array of round constants:
(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
k[0..63] :=
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

Pre-processing (Padding):
begin with the original message of length L bits
append a single '1' bit
append K '0' bits, where K is the minimum number >= 0 such that L + 1 + K + 64 is a multiple of 512
append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits

Process the message in successive 512-bit chunks:
break message into 512-bit chunks
for each chunk
    create a 64-entry message schedule array w[0..63] of 32-bit words
    (The initial values in w[0..63] don't matter, so many implementations zero them here)
    copy chunk into first 16 words w[0..15] of the message schedule array

    Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
    for i from 16 to 63
        s0 := (w[i-15] rightrotate  7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift  3)
        s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10)
        w[i] := w[i-16] + s0 + w[i-7] + s1

    Initialize working variables to current hash value:
    a := h0
    b := h1
    c := h2
    d := h3
    e := h4
    f := h5
    g := h6
    h := h7

    Compression function main loop:
    for i from 0 to 63
        S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
        ch := (e and f) xor ((not e) and g)
        temp1 := h + S1 + ch + k[i] + w[i]
        S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
        maj := (a and b) xor (a and c) xor (b and c)
        temp2 := S0 + maj
 
        h := g
        g := f
        f := e
        e := d + temp1
        d := c
        c := b
        b := a
        a := temp1 + temp2

    Add the compressed chunk to the current hash value:
    h0 := h0 + a
    h1 := h1 + b
    h2 := h2 + c
    h3 := h3 + d
    h4 := h4 + e
    h5 := h5 + f
    h6 := h6 + g
    h7 := h7 + h

Produce the final hash value (big-endian):
digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7
```



## 椭圆曲线密码学学习

### 椭圆曲线（Elliptic Curves）

#### 什么是椭圆曲线

而ECC算法所采用的椭圆曲线是一类可用Weierstrass公式加以描述的椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=E)

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%2BA_1+y%3Dx%5E3%2BA_2+x%5E2+%2BA_3x+%2B+A_4%5C%7D+%5C%5C)

其中参数![[公式]](https://www.zhihu.com/equation?tex=A_1)至 ![[公式]](https://www.zhihu.com/equation?tex=A_2)的不同取值决定椭圆曲线在坐标系中的形状。实际常用的形式是一类称为Weierstrass Normal Form（WNF）的的简化形式，即：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%3Dx%5E3%2Bax+%2B+b%5C%7D+%5C%5C)

由于ECC算法运算过程中需要使用WMF曲线的切线，因此为了使WNF曲线没有奇异点，即处处光滑可导，需要满足其判别式不为零，即：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq+0+%5C%5C)

同时，定义射影平面上的无穷远点，记为0.无穷远点是所有曲线在无穷远处的交点，也被称为理想点。因此，下面的论述当中所采用的完整的WNF椭圆曲线公式为：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%5Cmathbb%7BR%7D%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb%2C%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq0%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

当令![[公式]](https://www.zhihu.com/equation?tex=b%3D1)， ![[公式]](https://www.zhihu.com/equation?tex=a)从2递减1到-3的椭圆曲线如下所示：

![img](https://pic2.zhimg.com/80/v2-8d9e8ac56d444a7da4a42f25944e8e89_720w.jpg)

下面我们再来看两条存在奇异点的曲线，如下图所示：

![img](https://pic4.zhimg.com/80/v2-495147cc4f70c1772376ffc339e314a7_720w.jpg)

左边这条曲线的方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3)，右边的这条曲线方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B2)，两者都不是合格可用的椭圆曲线。另外，不难发现，所有的椭圆曲线都是关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的。

#### 群论

从数学的角度，一个群是由一种集合以及定义在该群上的一个二元运算所组成，且符合“群公理”。具体完整的定义如下：假设![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)是一个非空集合，![[公式]](https://www.zhihu.com/equation?tex=%2B)是它的一个二元运算，如果满足以下条件，则![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)和 ![[公式]](https://www.zhihu.com/equation?tex=%2B)构成一个群。

- 封闭性（closure）：若![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)是集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)的成员，则存在唯一确定的![[公式]](https://www.zhihu.com/equation?tex=c+%5Cin+%5Cmathbb%7BG%7D)，使得![[公式]](https://www.zhihu.com/equation?tex=c%3Da%2Bb)
- 结合律（associativity）：即对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中任意元素![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc)，都有![[公式]](https://www.zhihu.com/equation?tex=%28a%2Bb%29%2Bc%3Da%2B%28b%2Bc%29)
- 单位元（identify element）：存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=e) ，对任意所有的![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的元素![[公式]](https://www.zhihu.com/equation?tex=a)，总有等式![[公式]](https://www.zhihu.com/equation?tex=e%2Ba%3Da%2Be%3Da)。则将![[公式]](https://www.zhihu.com/equation?tex=e)称为单位元，也称幺元
- 逆元（inverse）：对于![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)任意一个![[公式]](https://www.zhihu.com/equation?tex=a)，存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=b)，使得总有![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba%3De)（![[公式]](https://www.zhihu.com/equation?tex=e)为单位元），则称![[公式]](https://www.zhihu.com/equation?tex=a)与 ![[公式]](https://www.zhihu.com/equation?tex=b) 互为逆元素，简称逆元。![[公式]](https://www.zhihu.com/equation?tex=b) 记作![[公式]](https://www.zhihu.com/equation?tex=a%5E%7B-1%7D)

群运算的次序很重要，把元素![[公式]](https://www.zhihu.com/equation?tex=a) 与元素![[公式]](https://www.zhihu.com/equation?tex=b)结合，所得到的结果不一定与把元素![[公式]](https://www.zhihu.com/equation?tex=b)与元素![[公式]](https://www.zhihu.com/equation?tex=a)结合相同；亦即，![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba)（交换律）不一定恒成立。满足交换律的群称为交换群（阿贝尔群，以尼尔斯·阿贝尔命名），不满足交换律的群称为非交换群（非阿贝尔群）。

如果我们将加法作为集合的二元运算，那么加上整数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D)将得到一个群，且是一个阿贝尔群。而自然数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D)因为不满足逆元，则无法与加法构成一个群。

群的奇妙之处在于如果你能够上述四个性质，那么你可以获得一些其它有趣的性质。

比如，单位元是独一无二的，逆元也是独一无二的。对于任何一个![[公式]](https://www.zhihu.com/equation?tex=a)，有且仅有一个![[公式]](https://www.zhihu.com/equation?tex=b)满足![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3D0)。

#### 椭圆曲线的群法则

- 群的元素是椭圆曲线上面的点的集合
- 单位元是在无穷远处的点，记为0
- 一个元素点![[公式]](https://www.zhihu.com/equation?tex=P)的逆元是其关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的点
- 二元远算操作规则定义如下：在曲线上面找到对齐的在一条直线上面的三个非零的点：![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)，三者之和为0，即![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)

![img](https://pic1.zhimg.com/80/v2-7cbef44d3018bd390d0ea6fa61f3af48_720w.jpg)

对于最后一点，我们的要求仅仅是一条直线上面对齐的三个点，而对齐本身与顺序是无关的，因此，如果![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)是对齐的，则有![[公式]](https://www.zhihu.com/equation?tex=P%2B%28Q%2BR%29%3DQ%2B%28P%2BR%29%3DR%2B%28P%2BQ%29%3D...%3D0)，如此这般，我们也顺带证明了我们所定义的二元操作符是能够同时满足结合律和交换律的，我们在椭圆曲线上面定义的群还是一个阿贝尔群。

#### 几何加法

庆幸我们是在一个阿贝尔群当中，我们可以将![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)写成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R)。这个形式的方程，可以让我们得到一种计算两个点![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)相加之和的几何方法：如果我们画一条直线通过![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，那么直线会与曲线相交与第三个点![[公式]](https://www.zhihu.com/equation?tex=R)。那么该点的逆元![[公式]](https://www.zhihu.com/equation?tex=-R)即为![[公式]](https://www.zhihu.com/equation?tex=P%2BQ)的结果。

![img](https://pic1.zhimg.com/80/v2-0ed62d5d6ac021ee2a0e0c3ccfce9c54_720w.jpg)

几何方法一目了然，但是还需要回答一些边界条件：

- ![[公式]](https://www.zhihu.com/equation?tex=P%3D0+%5C%2C+or%5C%2C+Q%3D0)：考虑到无穷远点本身并不在这个平面上面，线是画不出来的，但是我们已经定义了0为单位元，对于任意![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，都有![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3DP%E5%92%8C0%2BQ%3DQ)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3D-Q)：经过这两个点的直线是一条垂直线，与椭圆曲线不会有第三个交点。但是![[公式]](https://www.zhihu.com/equation?tex=P)是 ![[公式]](https://www.zhihu.com/equation?tex=Q)的逆元，根据逆元的定义有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3DP%2B%28-P%29%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)：会有无数条线经过这个点，情况会有一些复杂。令![[公式]](https://www.zhihu.com/equation?tex=Q%27%5Cneq+P)，如果我们让![[公式]](https://www.zhihu.com/equation?tex=Q%27)无限得接近![[公式]](https://www.zhihu.com/equation?tex=P)，则经过它们的直线会变成椭圆曲线的切线，此时有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R)，其中![[公式]](https://www.zhihu.com/equation?tex=R)是切线与椭圆曲线的交点。如下图所示：

![img](https://pic2.zhimg.com/v2-91b444e4c0e4c386495cb359b064c655_b.webp)

![[公式]](https://www.zhihu.com/equation?tex=P+%5Cneq+Q)，且找不到第三点![[公式]](https://www.zhihu.com/equation?tex=R)：这个情况与上面的情况非常类似，此时过![[公式]](https://www.zhihu.com/equation?tex=P%2CQ)的线就是椭圆曲线的切线。假设![[公式]](https://www.zhihu.com/equation?tex=P)就是切点，在前面的一个情况当中，![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-Q)，这个方程现在变成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-P)。反过来，如果![[公式]](https://www.zhihu.com/equation?tex=Q)是这个切点，则有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-Q)。如下图所示：

![img](https://pic2.zhimg.com/v2-ba1669a982efc7cd7786c74c372dfecd_b.webp)



现在几何加法已经能够覆盖所有的情况了，你只需要尺规就可以在椭圆曲线上面进行各种加法计算了。如果有兴趣也可以看看本文主要参考资料作者提供的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，这个工具提供了在实数域和离散有限域上面的加法和乘法实现，可以直观的看出这两者的区别，便于对文章的理解。

#### 代数加法

如果要使用计算机进行具体的加法远算，那么要从几何方法切换到代数方法。将以上所描述的规则转化为方程组是直截了当的办法，但是因为涉及到求解三次方程，会非常麻烦，这里仅仅给出最终结果，具体的求解和推导过程可以查阅相关资料，比如wiki百科等。

首先，对于简单的边界条件先排除掉，我们已经知道![[公式]](https://www.zhihu.com/equation?tex=P%2B%28-P%29%3D0)，以及![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3D0%2BP%3DP)。因此，我们只需要考虑两个非零且不对称的点![[公式]](https://www.zhihu.com/equation?tex=P%3D%28x_P%2Cy_P%29%2CQ%3D%28x_Q%2Cy_Q%29)。

如果![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)不相等，则通过这两个点的直线的斜率为：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D+%5C%5C)

则直线与椭圆曲线的第三个交点![[公式]](https://www.zhihu.com/equation?tex=R%28x_R%2Cy_R%29)的坐标如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_R%26%3Dm%5E2-x_P-x_Q%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29+%5Cend%7Balign%7D+%5C%5C)

或者，等价于：

![[公式]](https://www.zhihu.com/equation?tex=y_R%3Dy_Q%2Bm%28x_R-x_Q%29+%5C%5C)

因此有：![[公式]](https://www.zhihu.com/equation?tex=%28x_P%2Cy_P%29%2B%28x_Q%2Cy_Q%29%3D%28x_R%2C-y_R%29)，需要注意![[公式]](https://www.zhihu.com/equation?tex=y_R)的负号。

为了验证结果的正确性，需要验证以下两点：

- ![[公式]](https://www.zhihu.com/equation?tex=R)是否在这条曲线上面
- ![[公式]](https://www.zhihu.com/equation?tex=P%2CQ%2CR)是否共线

验证三点是否共线相对简单，而验证一个点是否在椭圆曲线上面则相对复杂一些，需要求解三次方程。这里我们还是借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，在曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-7x%2B10)上面取两点![[公式]](https://www.zhihu.com/equation?tex=P%3D%281%2C2%29%2CQ%3D%283%2C4%29)，得到![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R%3D%28-3%EF%BC%8C2%29)，我们由此验证下前面的代数表达式是否正确：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D%3D%5Cfrac%7B2-4%7D%7B1-3%7D%3D1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D1%5E2-1-3%3D-3%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B1+%5Ctimes%28-3-1%29%3D-2%5C%5C+%26%3Dy_Q%2Bm%28x_R-x_Q%29%3D4%2B1+%5Ctimes%28-3-3%29%3D-2+%5Cend%7Balign%7D+%5C%5C)

另外，当![[公式]](https://www.zhihu.com/equation?tex=P)或者![[公式]](https://www.zhihu.com/equation?tex=Q)其中之一是切点的时候，上述方程依然正确，具体读者可以自行验证。

而当![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)时，情况会稍微复杂一些：因为![[公式]](https://www.zhihu.com/equation?tex=x_P%3Dx_Q)，所以关于斜率我们需要采用另外一个不同的方程：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D+%5C%5C)

不难发现，正如我们期望的那样，上述![[公式]](https://www.zhihu.com/equation?tex=m)的表达式就是下式的一阶导数：

![[公式]](https://www.zhihu.com/equation?tex=y_P%3D%5Cpm+%5Csqrt%7Bx%5E3_P%2Bax_P%2Bb%7D+%5C%5C)

为了证明这一结果的有效性，只需检查![[公式]](https://www.zhihu.com/equation?tex=R)在这条椭圆曲线上，以及经过![[公式]](https://www.zhihu.com/equation?tex=R)和 ![[公式]](https://www.zhihu.com/equation?tex=P)的直线与椭圆曲线只有两个交点。当然，具体证明还是交给相关专业的数学教材，这里只举一个具体的例子：![[公式]](https://www.zhihu.com/equation?tex=P%3DQ%3D%281%EF%BC%8C2%29)。

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D%3D%5Cfrac%7B3%5Ctimes+1%5E2-7%7D%7B2%5Ctimes+2%7D%3D-1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D%28-1%29%5E2-1-1%3D-1%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B%28-1%29+%5Ctimes%28-1-1%29%3D4+%5Cend%7Balign%7D+%5C%5C)

这里我们有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R%3D%28-1%2C-4%29)，结果正确。

#### 标量乘法（Scalar multiplication）

除了加法，我们可以定义另外一个操作：标量乘法，具体如下：

![[公式]](https://www.zhihu.com/equation?tex=nP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D+%5C%5C)

其中![[公式]](https://www.zhihu.com/equation?tex=n)是一个自然数。这里我们依然可以借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**对标量乘法进行演示。

从上面的形式可以看出，计算标量乘法![[公式]](https://www.zhihu.com/equation?tex=nP)需要进行![[公式]](https://www.zhihu.com/equation?tex=n)次的加法。如果![[公式]](https://www.zhihu.com/equation?tex=n)有 ![[公式]](https://www.zhihu.com/equation?tex=k)个二进制位的话，那么我们的算法复杂度将是![[公式]](https://www.zhihu.com/equation?tex=O%282%5Ek%29)，不过，对于乘法的计算有现成的更为优化的多项式级别复杂度的算法。

其中一个比较著名的是**加倍累加（double and add ）**算法。我们用一个具体的例子来解释其原理。不妨取![[公式]](https://www.zhihu.com/equation?tex=n%3D151)，其二进制表示形式为：![[公式]](https://www.zhihu.com/equation?tex=%7B10010111%7D_2)。而将二进制转化为十进制的过程可以用2的不同次方的累加表示如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+151%26%3D1%5Ctimes+2%5E7+%2B+0+%5Ctimes+2%5E6+%2B+0+%5Ctimes+2%5E5+%2B+1+%5Ctimes+2%5E4+%2B+0+%5Ctimes+2%5E3+%2B+1+%5Ctimes+2%5E2+%2B+1%5Ctimes+2%5E1+%2B+1%5Ctimes+2%5E0%5C%5C+%26%3D2%5E7%2B2%5E4%2B2%5E2%2B2%5E1%2B2%5E0+%5Cend%7Balign%7D+%5C%5C)

从这个角度，我们可以改写上述变量乘法公式：

![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P%3D2%5E7%5Ctimes+P%2B2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P+%2B+2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P+%5C%5C)

这样，标量乘法可以表示为多项式乘法类似的算法，具体步骤如下：

- 得到![[公式]](https://www.zhihu.com/equation?tex=P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=P)，得到![[公式]](https://www.zhihu.com/equation?tex=2P)
- 将![[公式]](https://www.zhihu.com/equation?tex=2P)加到![[公式]](https://www.zhihu.com/equation?tex=P)（得到![[公式]](https://www.zhihu.com/equation?tex=2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)的结果）
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)
- 不对![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)进行任何操作
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- ...

最后，我们仅需要7次的翻倍计算和4次的加法计算就可以得到![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P)的结果。

这里我们分析下这个算法的时间复杂度。如果翻倍和加法都是![[公式]](https://www.zhihu.com/equation?tex=O%281%29)的话，那么这个算法就是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)，比起之前的![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)，算法时间复杂度大大简化。

#### 对数问题（logarithm problem）

给定![[公式]](https://www.zhihu.com/equation?tex=n)和 ![[公式]](https://www.zhihu.com/equation?tex=P)，我们有一个至少是多项式时间复杂度的算法来计算![[公式]](https://www.zhihu.com/equation?tex=Q%3DnP)。但是，如果反过来呢？比如已知![[公式]](https://www.zhihu.com/equation?tex=Q)和 ![[公式]](https://www.zhihu.com/equation?tex=P)来计算![[公式]](https://www.zhihu.com/equation?tex=n)呢？通常将这种问题叫作对数问题（logarithm problem）。之所以用对数来代替除法是为了与其它的加密系统保持一致。

对于对数问题我们不知道是否有可以称之为“简单”的算法，但是通过**[一些乘法实验](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-mul.html%3Fa%3D-3%26b%3D1%26px%3D0%26py%3D1)**还是很容易看出一些规律的。比如，以椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B1)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%280%2C1%29)为例。我们可以立刻确认，如果![[公式]](https://www.zhihu.com/equation?tex=n)是奇数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的左半部分；如果![[公式]](https://www.zhihu.com/equation?tex=n)是偶数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的右半部分。如果我们做更多的实验，我们可以发现更多的规律，最终可以指引我们写出一个基于特定曲线的求解对数问题的特定算法。

当然，对数问题也有一些衍生：离散对数问题。这个将在下一篇文章当中进行讨论，如果我们减小椭圆曲线的域，变量乘法依然“简单”，但是离散对数却变成一个“难题”，这个双重特性是椭圆曲线密码学的基石。