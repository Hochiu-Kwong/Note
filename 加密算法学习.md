

# 密码学学习

**2020.10.14**

***

## SHA256 算法原理及介绍 

### SHA-2 族算法简介

* 一个`n`位的哈希函数就是一个从任意长的消息到`n`位哈希值的映射，一个`n`位的加密哈希函数就是一个单向的、避免碰撞的`n`位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。

### SHA256原理详解

#### 简介

* 对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。
* 例子：`blockchain` 的SHA-256具有如下哈希值
* `3a6fed5fc11392b3ee9f81caf017b48640d7458766a8eb0382899a605b41f2b9`
* 总体上，HSA256与MD4、MD5以及HSA-1等哈希函数的操作流程类似，待哈希的消息在继续哈希计算之前首先要进行以下两个步骤：
* 对消息进行补位处理，是的最终的长度是512位的倍数，然后
* 以512位为单位对消息进行分块为![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D)
* 消息区块将进行逐个处理：从一个固定的初始哈希![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)开始，进行以下序列的计算：
* ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D%3DH%5E%7B%28i-1%29%7D%2BC_%7BM%5E%7B%28i%29%7D+%7D%28H%5E%7B%28i-1%29%7D%29+%5C%5C)

#### 常量初始化

* 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位

* ![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7B2%7D)小数部分约为0.414213562373095048

* ![[公式]](https://www.zhihu.com/equation?tex=0.414213562373095048+%5Capprox+6%2A16%5E%7B-1%7D%2Ba%2A16%5E%7B-2%7D%2B0%2A16%5E%7B-3%7D%2B...+%5C%5C)

* 于是, 质数2的平方根的小数部分取前32位就对应`0x6a09e667`

* 如此类推, 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)由以下8个32位的哈希初值构成:

  ![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%280%29%7D_1%26%3D6a09e667%5C%5C+H%5E%7B%280%29%7D_2%26%3Dbb67ae85%5C%5C+H%5E%7B%280%29%7D_3%26%3D3c6ef372%5C%5C+H%5E%7B%280%29%7D_4%26%3Da54ff53a%5C%5C+H%5E%7B%280%29%7D_5%26%3D510e527f%5C%5C+H%5E%7B%280%29%7D_6%26%3D9b05688c%5C%5C+H%5E%7B%280%29%7D_7%26%3D1f83d9ab%5C%5C+H%5E%7B%280%29%7D_8%26%3D5be0cd19+%5Cend%7Balign%7D+%5C%5C)

* SHA256算法当中还使用到64个常数, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下

* ```text
  428a2f98 71374491 b5c0fbcf e9b5dba5
  3956c25b 59f111f1 923f82a4 ab1c5ed5
  d807aa98 12835b01 243185be 550c7dc3
  72be5d74 80deb1fe 9bdc06a7 c19bf174
  e49b69c1 efbe4786 0fc19dc6 240ca1cc
  2de92c6f 4a7484aa 5cb0a9dc 76f988da
  983e5152 a831c66d b00327c8 bf597fc7
  c6e00bf3 d5a79147 06ca6351 14292967
  27b70a85 2e1b2138 4d2c6dfc 53380d13
  650a7354 766a0abb 81c2c92e 92722c85
  a2bfe8a1 a81a664b c24b8b70 c76c51a3
  d192e819 d6990624 f40e3585 106aa070
  19a4c116 1e376c08 2748774c 34b0bcb5
  391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
  748f82ee 78a5636f 84c87814 8cc70208
  90befffa a4506ceb bef9a3f7 c67178f2
  ```

#### 消息预处理

* 在计算消息的哈希摘要之前需要对消息进行预处理:

* 对消息进行补码处理: 假设消息![[公式]](https://www.zhihu.com/equation?tex=M)的二进制编码长度为![[公式]](https://www.zhihu.com/equation?tex=l)位. 首先在消息末尾补上一位"1", 然后再补上![[公式]](https://www.zhihu.com/equation?tex=k)个"0", 其中![[公式]](https://www.zhihu.com/equation?tex=k)为下列方程的最小非负整数

* ![[公式]](https://www.zhihu.com/equation?tex=l%2B1%2Bk%5Cequiv448%5Cmod+512+%5C%5C)

* 举个例子, 以消息"abc"为例显示补位的过程.

  a,b,c对应的**[ASCII码](https://link.zhihu.com/?target=http%3A//ascii.911cha.com/)**和二进制编码分别如下:

  ```text
  原始字符    ASCII码    二进制编码
  a          97         01100001
  b          98         01100010
  c          99         01100011
  ```

* 因此, 原始信息"abc"的二进制编码为:`01100001 01100010 01100011`, 第一步补位, 首先在消息末尾补上一位"1", 结果为: `01100001 01100010 01100011 1`; 然后进行第二步的补位, 因为![[公式]](https://www.zhihu.com/equation?tex=l%3D24), 可以得到![[公式]](https://www.zhihu.com/equation?tex=k%3D423), 在第一步补位后的消息后面再补423个"0", 结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D+%5C%5C)

* 最后还需要在上述字节串后面继续进行补码, 这个时候补的是原消息"abc"的二进制长度![[公式]](https://www.zhihu.com/equation?tex=l%3D24)的64位二进制表示形式, 补完以后的结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D%5C%2C%5Cunderbrace%7B00...011000%7D_%7B64%7D+%5C%5C)

* 最终补完以后的消息二进制位数长度是512的倍数

* 这里需要注意的两点是不管原来的消息长度是多少, 即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位. 另外, 考虑到最后要将消息长度![[公式]](https://www.zhihu.com/equation?tex=l)转换为64位二进制编码, 因此, 长度的必须小于![[公式]](https://www.zhihu.com/equation?tex=2%5E%7B64%7D), 绝大多数情况, 这个足够大了

* 将补码处理后的消息以512位为单位分块为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D), 其中第![[公式]](https://www.zhihu.com/equation?tex=i)个消息块的前32位表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_0), 后面32位为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_1), 以此类推, 最后32位的消息块可表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_%7B15%7D). 我们采用Big endian约定对数据进行编码, 即认为第一个字节是最高位字节, 因此, 对于每一个32位字节, 最最左边的比特是最大的比特位

#### 摘要计算主循环

哈希计算算法如下:

- ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+i+%3D+1+%5Cto+N) (![[公式]](https://www.zhihu.com/equation?tex=N) = 补码后消息块个数)

- - 用第![[公式]](https://www.zhihu.com/equation?tex=+%28i+-+1%29)个中间哈希值来对 ![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc%2Cd%2Ce%2Cf%2Cg%2Ch)进行初始化, 当![[公式]](https://www.zhihu.com/equation?tex=i%3D1)时, 就使用初始化哈希, 即:

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+a%26%5Cgets+H%5E%7B%28i-1%29%7D_1%5C%5C+b%26%5Cgets+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+h%26%5Cgets+H%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- 应用SHA256压缩函数来更新![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2C...%2Ch)

- - ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+j+%3D+0+%5Cto+63)

  - - 计算![[公式]](https://www.zhihu.com/equation?tex=Ch%28e%2Cf%2Cg%29%2C+M_%7Baj%7D%28a%2Cb%2Cc%29%2C+%5CSigma_0%28a%29%2C+%5CSigma_1%28e%29%2C+W_j)(具体定义如下)
    - PS：对于每一块M，将块分解为16个32-bit的big-endian的字，记为w[0], …, w[15]，其余的字由如下迭代公式得到：
    - ![[公式]](https://www.zhihu.com/equation?tex=W_j%5Cgets+%5Csigma_1%28W_%7Bj-2%7D%29%2BW_%7Bj-7%7D%2B%5Csigma_0%28W_%7Bj-15%7D%29%2BW_%7Bj-16%7D)
    - 进行下面运算

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+T_1+%26%5Cgets+h%2B%5CSigma_1%28e%29%2BCh%28e%2Cf%2Cg%29%2BK_j%2BW_j%5C%5C+T_2%26%5Cgets+%5CSigma_0%28a%29%2BM_%7Baj%7D%28a%2Cb%2Cc%29%5C%5C+h%26%5Cgets+g%5C%5C+g%26%5Cgets+f%5C%5C+f%26%5Cgets+e%5C%5C+e%26%5Cgets+d%2BT_1%5C%5C+d%26%5Cgets+c%5C%5C+c%26%5Cgets+b%5C%5C+b%26%5Cgets+a%5C%5C+a%26%5Cgets+T_1%2BT_2+%5Cend%7Balign%7D+%5C%5C)

- 计算第![[公式]](https://www.zhihu.com/equation?tex=i)个中间哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D)

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%28i%29%7D_1+%26%5Cgets+a+%2B+H%5E%7B%28i-1%29%7D_1%5C%5C+H%5E%7B%28i%29%7D_2+%26%5Cgets+b%2B+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+H%5E%7B%28i%29%7D_8+%26%5Cgets+h%2BH%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28N%29%7D%3D%28H%5E%7B%28N%29%7D_1%2CH%5E%7B%28N%29%7D_2%2C...%2CH%5E%7B%28N%29%7D_8%29)为最终需要的哈希![[公式]](https://www.zhihu.com/equation?tex=M)。



### SHA伪代码

```text
Note 1: All variables are 32 bit unsigned integers and addition is calculated modulo 232
Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 ≤ i ≤ 63
Note 3: The compression function uses 8 working variables, a through h
Note 4: Big-endian convention is used when expressing the constants in this pseudocode,
    and when parsing message block data from bytes to words, for example,
    the first word of the input message "abc" after padding is 0x61626380

Initialize hash values:
(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
h0 := 0x6a09e667
h1 := 0xbb67ae85
h2 := 0x3c6ef372
h3 := 0xa54ff53a
h4 := 0x510e527f
h5 := 0x9b05688c
h6 := 0x1f83d9ab
h7 := 0x5be0cd19

Initialize array of round constants:
(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
k[0..63] :=
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

Pre-processing (Padding):
begin with the original message of length L bits
append a single '1' bit
append K '0' bits, where K is the minimum number >= 0 such that L + 1 + K + 64 is a multiple of 512
append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits

Process the message in successive 512-bit chunks:
break message into 512-bit chunks
for each chunk
    create a 64-entry message schedule array w[0..63] of 32-bit words
    (The initial values in w[0..63] don't matter, so many implementations zero them here)
    copy chunk into first 16 words w[0..15] of the message schedule array

    Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
    for i from 16 to 63
        s0 := (w[i-15] rightrotate  7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift  3)
        s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10)
        w[i] := w[i-16] + s0 + w[i-7] + s1

    Initialize working variables to current hash value:
    a := h0
    b := h1
    c := h2
    d := h3
    e := h4
    f := h5
    g := h6
    h := h7

    Compression function main loop:
    for i from 0 to 63
        S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
        ch := (e and f) xor ((not e) and g)
        temp1 := h + S1 + ch + k[i] + w[i]
        S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
        maj := (a and b) xor (a and c) xor (b and c)
        temp2 := S0 + maj
 
        h := g
        g := f
        f := e
        e := d + temp1
        d := c
        c := b
        b := a
        a := temp1 + temp2

    Add the compressed chunk to the current hash value:
    h0 := h0 + a
    h1 := h1 + b
    h2 := h2 + c
    h3 := h3 + d
    h4 := h4 + e
    h5 := h5 + f
    h6 := h6 + g
    h7 := h7 + h

Produce the final hash value (big-endian):
digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7
```



## 椭圆曲线密码学学习

### 椭圆曲线（Elliptic Curves）

#### 什么是椭圆曲线

而ECC算法所采用的椭圆曲线是一类可用Weierstrass公式加以描述的椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=E)

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%2BA_1+y%3Dx%5E3%2BA_2+x%5E2+%2BA_3x+%2B+A_4%5C%7D+%5C%5C)

其中参数![[公式]](https://www.zhihu.com/equation?tex=A_1)至 ![[公式]](https://www.zhihu.com/equation?tex=A_2)的不同取值决定椭圆曲线在坐标系中的形状。实际常用的形式是一类称为Weierstrass Normal Form（WNF）的的简化形式，即：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%3Dx%5E3%2Bax+%2B+b%5C%7D+%5C%5C)

由于ECC算法运算过程中需要使用WMF曲线的切线，因此为了使WNF曲线没有奇异点，即处处光滑可导，需要满足其判别式不为零，即：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq+0+%5C%5C)

同时，定义射影平面上的无穷远点，记为0.无穷远点是所有曲线在无穷远处的交点，也被称为理想点。因此，下面的论述当中所采用的完整的WNF椭圆曲线公式为：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%5Cmathbb%7BR%7D%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb%2C%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq0%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

当令![[公式]](https://www.zhihu.com/equation?tex=b%3D1)， ![[公式]](https://www.zhihu.com/equation?tex=a)从2递减1到-3的椭圆曲线如下所示：

![img](https://pic2.zhimg.com/80/v2-8d9e8ac56d444a7da4a42f25944e8e89_720w.jpg)

下面我们再来看两条存在奇异点的曲线，如下图所示：

![img](https://pic4.zhimg.com/80/v2-495147cc4f70c1772376ffc339e314a7_720w.jpg)

左边这条曲线的方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3)，右边的这条曲线方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B2)，两者都不是合格可用的椭圆曲线。另外，不难发现，所有的椭圆曲线都是关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的。

#### 群论

从数学的角度，一个群是由一种集合以及定义在该群上的一个二元运算所组成，且符合“群公理”。具体完整的定义如下：假设![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)是一个非空集合，![[公式]](https://www.zhihu.com/equation?tex=%2B)是它的一个二元运算，如果满足以下条件，则![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)和 ![[公式]](https://www.zhihu.com/equation?tex=%2B)构成一个群。

- 封闭性（closure）：若![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)是集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)的成员，则存在唯一确定的![[公式]](https://www.zhihu.com/equation?tex=c+%5Cin+%5Cmathbb%7BG%7D)，使得![[公式]](https://www.zhihu.com/equation?tex=c%3Da%2Bb)
- 结合律（associativity）：即对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中任意元素![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc)，都有![[公式]](https://www.zhihu.com/equation?tex=%28a%2Bb%29%2Bc%3Da%2B%28b%2Bc%29)
- 单位元（identify element）：存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=e) ，对任意所有的![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的元素![[公式]](https://www.zhihu.com/equation?tex=a)，总有等式![[公式]](https://www.zhihu.com/equation?tex=e%2Ba%3Da%2Be%3Da)。则将![[公式]](https://www.zhihu.com/equation?tex=e)称为单位元，也称幺元
- 逆元（inverse）：对于![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)任意一个![[公式]](https://www.zhihu.com/equation?tex=a)，存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=b)，使得总有![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba%3De)（![[公式]](https://www.zhihu.com/equation?tex=e)为单位元），则称![[公式]](https://www.zhihu.com/equation?tex=a)与 ![[公式]](https://www.zhihu.com/equation?tex=b) 互为逆元素，简称逆元。![[公式]](https://www.zhihu.com/equation?tex=b) 记作![[公式]](https://www.zhihu.com/equation?tex=a%5E%7B-1%7D)

群运算的次序很重要，把元素![[公式]](https://www.zhihu.com/equation?tex=a) 与元素![[公式]](https://www.zhihu.com/equation?tex=b)结合，所得到的结果不一定与把元素![[公式]](https://www.zhihu.com/equation?tex=b)与元素![[公式]](https://www.zhihu.com/equation?tex=a)结合相同；亦即，![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba)（交换律）不一定恒成立。满足交换律的群称为交换群（阿贝尔群，以尼尔斯·阿贝尔命名），不满足交换律的群称为非交换群（非阿贝尔群）。

如果我们将加法作为集合的二元运算，那么加上整数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D)将得到一个群，且是一个阿贝尔群。而自然数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D)因为不满足逆元，则无法与加法构成一个群。

群的奇妙之处在于如果你能够上述四个性质，那么你可以获得一些其它有趣的性质。

比如，单位元是独一无二的，逆元也是独一无二的。对于任何一个![[公式]](https://www.zhihu.com/equation?tex=a)，有且仅有一个![[公式]](https://www.zhihu.com/equation?tex=b)满足![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3D0)。

#### 椭圆曲线的群法则

- 群的元素是椭圆曲线上面的点的集合
- 单位元是在无穷远处的点，记为0
- 一个元素点![[公式]](https://www.zhihu.com/equation?tex=P)的逆元是其关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的点
- 二元远算操作规则定义如下：在曲线上面找到对齐的在一条直线上面的三个非零的点：![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)，三者之和为0，即![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)

![img](https://pic1.zhimg.com/80/v2-7cbef44d3018bd390d0ea6fa61f3af48_720w.jpg)

对于最后一点，我们的要求仅仅是一条直线上面对齐的三个点，而对齐本身与顺序是无关的，因此，如果![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)是对齐的，则有![[公式]](https://www.zhihu.com/equation?tex=P%2B%28Q%2BR%29%3DQ%2B%28P%2BR%29%3DR%2B%28P%2BQ%29%3D...%3D0)，如此这般，我们也顺带证明了我们所定义的二元操作符是能够同时满足结合律和交换律的，我们在椭圆曲线上面定义的群还是一个阿贝尔群。

#### 几何加法

庆幸我们是在一个阿贝尔群当中，我们可以将![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)写成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R)。这个形式的方程，可以让我们得到一种计算两个点![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)相加之和的几何方法：如果我们画一条直线通过![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，那么直线会与曲线相交与第三个点![[公式]](https://www.zhihu.com/equation?tex=R)。那么该点的逆元![[公式]](https://www.zhihu.com/equation?tex=-R)即为![[公式]](https://www.zhihu.com/equation?tex=P%2BQ)的结果。

![img](https://pic1.zhimg.com/80/v2-0ed62d5d6ac021ee2a0e0c3ccfce9c54_720w.jpg)

几何方法一目了然，但是还需要回答一些边界条件：

- ![[公式]](https://www.zhihu.com/equation?tex=P%3D0+%5C%2C+or%5C%2C+Q%3D0)：考虑到无穷远点本身并不在这个平面上面，线是画不出来的，但是我们已经定义了0为单位元，对于任意![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，都有![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3DP%E5%92%8C0%2BQ%3DQ)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3D-Q)：经过这两个点的直线是一条垂直线，与椭圆曲线不会有第三个交点。但是![[公式]](https://www.zhihu.com/equation?tex=P)是 ![[公式]](https://www.zhihu.com/equation?tex=Q)的逆元，根据逆元的定义有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3DP%2B%28-P%29%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)：会有无数条线经过这个点，情况会有一些复杂。令![[公式]](https://www.zhihu.com/equation?tex=Q%27%5Cneq+P)，如果我们让![[公式]](https://www.zhihu.com/equation?tex=Q%27)无限得接近![[公式]](https://www.zhihu.com/equation?tex=P)，则经过它们的直线会变成椭圆曲线的切线，此时有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R)，其中![[公式]](https://www.zhihu.com/equation?tex=R)是切线与椭圆曲线的交点。如下图所示：

![img](https://pic2.zhimg.com/v2-91b444e4c0e4c386495cb359b064c655_b.webp)

![[公式]](https://www.zhihu.com/equation?tex=P+%5Cneq+Q)，且找不到第三点![[公式]](https://www.zhihu.com/equation?tex=R)：这个情况与上面的情况非常类似，此时过![[公式]](https://www.zhihu.com/equation?tex=P%2CQ)的线就是椭圆曲线的切线。假设![[公式]](https://www.zhihu.com/equation?tex=P)就是切点，在前面的一个情况当中，![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-Q)，这个方程现在变成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-P)。反过来，如果![[公式]](https://www.zhihu.com/equation?tex=Q)是这个切点，则有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-Q)。如下图所示：

![img](https://pic2.zhimg.com/v2-ba1669a982efc7cd7786c74c372dfecd_b.webp)



现在几何加法已经能够覆盖所有的情况了，你只需要尺规就可以在椭圆曲线上面进行各种加法计算了。如果有兴趣也可以看看本文主要参考资料作者提供的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，这个工具提供了在实数域和离散有限域上面的加法和乘法实现，可以直观的看出这两者的区别，便于对文章的理解。

#### 代数加法

如果要使用计算机进行具体的加法远算，那么要从几何方法切换到代数方法。将以上所描述的规则转化为方程组是直截了当的办法，但是因为涉及到求解三次方程，会非常麻烦，这里仅仅给出最终结果，具体的求解和推导过程可以查阅相关资料，比如wiki百科等。

首先，对于简单的边界条件先排除掉，我们已经知道![[公式]](https://www.zhihu.com/equation?tex=P%2B%28-P%29%3D0)，以及![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3D0%2BP%3DP)。因此，我们只需要考虑两个非零且不对称的点![[公式]](https://www.zhihu.com/equation?tex=P%3D%28x_P%2Cy_P%29%2CQ%3D%28x_Q%2Cy_Q%29)。

如果![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)不相等，则通过这两个点的直线的斜率为：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D+%5C%5C)

则直线与椭圆曲线的第三个交点![[公式]](https://www.zhihu.com/equation?tex=R%28x_R%2Cy_R%29)的坐标如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_R%26%3Dm%5E2-x_P-x_Q%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29+%5Cend%7Balign%7D+%5C%5C)

或者，等价于：

![[公式]](https://www.zhihu.com/equation?tex=y_R%3Dy_Q%2Bm%28x_R-x_Q%29+%5C%5C)

因此有：![[公式]](https://www.zhihu.com/equation?tex=%28x_P%2Cy_P%29%2B%28x_Q%2Cy_Q%29%3D%28x_R%2C-y_R%29)，需要注意![[公式]](https://www.zhihu.com/equation?tex=y_R)的负号。

为了验证结果的正确性，需要验证以下两点：

- ![[公式]](https://www.zhihu.com/equation?tex=R)是否在这条曲线上面
- ![[公式]](https://www.zhihu.com/equation?tex=P%2CQ%2CR)是否共线

验证三点是否共线相对简单，而验证一个点是否在椭圆曲线上面则相对复杂一些，需要求解三次方程。这里我们还是借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，在曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-7x%2B10)上面取两点![[公式]](https://www.zhihu.com/equation?tex=P%3D%281%2C2%29%2CQ%3D%283%2C4%29)，得到![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R%3D%28-3%EF%BC%8C2%29)，我们由此验证下前面的代数表达式是否正确：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D%3D%5Cfrac%7B2-4%7D%7B1-3%7D%3D1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D1%5E2-1-3%3D-3%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B1+%5Ctimes%28-3-1%29%3D-2%5C%5C+%26%3Dy_Q%2Bm%28x_R-x_Q%29%3D4%2B1+%5Ctimes%28-3-3%29%3D-2+%5Cend%7Balign%7D+%5C%5C)

另外，当![[公式]](https://www.zhihu.com/equation?tex=P)或者![[公式]](https://www.zhihu.com/equation?tex=Q)其中之一是切点的时候，上述方程依然正确，具体读者可以自行验证。

而当![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)时，情况会稍微复杂一些：因为![[公式]](https://www.zhihu.com/equation?tex=x_P%3Dx_Q)，所以关于斜率我们需要采用另外一个不同的方程：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D+%5C%5C)

不难发现，正如我们期望的那样，上述![[公式]](https://www.zhihu.com/equation?tex=m)的表达式就是下式的一阶导数：

![[公式]](https://www.zhihu.com/equation?tex=y_P%3D%5Cpm+%5Csqrt%7Bx%5E3_P%2Bax_P%2Bb%7D+%5C%5C)

为了证明这一结果的有效性，只需检查![[公式]](https://www.zhihu.com/equation?tex=R)在这条椭圆曲线上，以及经过![[公式]](https://www.zhihu.com/equation?tex=R)和 ![[公式]](https://www.zhihu.com/equation?tex=P)的直线与椭圆曲线只有两个交点。当然，具体证明还是交给相关专业的数学教材，这里只举一个具体的例子：![[公式]](https://www.zhihu.com/equation?tex=P%3DQ%3D%281%EF%BC%8C2%29)。

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D%3D%5Cfrac%7B3%5Ctimes+1%5E2-7%7D%7B2%5Ctimes+2%7D%3D-1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D%28-1%29%5E2-1-1%3D-1%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B%28-1%29+%5Ctimes%28-1-1%29%3D4+%5Cend%7Balign%7D+%5C%5C)

这里我们有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R%3D%28-1%2C-4%29)，结果正确。

#### 标量乘法（Scalar multiplication）

除了加法，我们可以定义另外一个操作：标量乘法，具体如下：

![[公式]](https://www.zhihu.com/equation?tex=nP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D+%5C%5C)

其中![[公式]](https://www.zhihu.com/equation?tex=n)是一个自然数。这里我们依然可以借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**对标量乘法进行演示。

从上面的形式可以看出，计算标量乘法![[公式]](https://www.zhihu.com/equation?tex=nP)需要进行![[公式]](https://www.zhihu.com/equation?tex=n)次的加法。如果![[公式]](https://www.zhihu.com/equation?tex=n)有 ![[公式]](https://www.zhihu.com/equation?tex=k)个二进制位的话，那么我们的算法复杂度将是![[公式]](https://www.zhihu.com/equation?tex=O%282%5Ek%29)，不过，对于乘法的计算有现成的更为优化的多项式级别复杂度的算法。

其中一个比较著名的是**加倍累加（double and add ）**算法。我们用一个具体的例子来解释其原理。不妨取![[公式]](https://www.zhihu.com/equation?tex=n%3D151)，其二进制表示形式为：![[公式]](https://www.zhihu.com/equation?tex=%7B10010111%7D_2)。而将二进制转化为十进制的过程可以用2的不同次方的累加表示如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+151%26%3D1%5Ctimes+2%5E7+%2B+0+%5Ctimes+2%5E6+%2B+0+%5Ctimes+2%5E5+%2B+1+%5Ctimes+2%5E4+%2B+0+%5Ctimes+2%5E3+%2B+1+%5Ctimes+2%5E2+%2B+1%5Ctimes+2%5E1+%2B+1%5Ctimes+2%5E0%5C%5C+%26%3D2%5E7%2B2%5E4%2B2%5E2%2B2%5E1%2B2%5E0+%5Cend%7Balign%7D+%5C%5C)

从这个角度，我们可以改写上述变量乘法公式：

![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P%3D2%5E7%5Ctimes+P%2B2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P+%2B+2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P+%5C%5C)

这样，标量乘法可以表示为多项式乘法类似的算法，具体步骤如下：

- 得到![[公式]](https://www.zhihu.com/equation?tex=P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=P)，得到![[公式]](https://www.zhihu.com/equation?tex=2P)
- 将![[公式]](https://www.zhihu.com/equation?tex=2P)加到![[公式]](https://www.zhihu.com/equation?tex=P)（得到![[公式]](https://www.zhihu.com/equation?tex=2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)的结果）
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)
- 不对![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)进行任何操作
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- ...

最后，我们仅需要7次的翻倍计算和4次的加法计算就可以得到![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P)的结果。

这里我们分析下这个算法的时间复杂度。如果翻倍和加法都是![[公式]](https://www.zhihu.com/equation?tex=O%281%29)的话，那么这个算法就是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)，比起之前的![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)，算法时间复杂度大大简化。

#### 对数问题（logarithm problem）

给定![[公式]](https://www.zhihu.com/equation?tex=n)和 ![[公式]](https://www.zhihu.com/equation?tex=P)，我们有一个至少是多项式时间复杂度的算法来计算![[公式]](https://www.zhihu.com/equation?tex=Q%3DnP)。但是，如果反过来呢？比如已知![[公式]](https://www.zhihu.com/equation?tex=Q)和 ![[公式]](https://www.zhihu.com/equation?tex=P)来计算![[公式]](https://www.zhihu.com/equation?tex=n)呢？通常将这种问题叫作对数问题（logarithm problem）。之所以用对数来代替除法是为了与其它的加密系统保持一致。

对于对数问题我们不知道是否有可以称之为“简单”的算法，但是通过**[一些乘法实验](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-mul.html%3Fa%3D-3%26b%3D1%26px%3D0%26py%3D1)**还是很容易看出一些规律的。比如，以椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B1)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%280%2C1%29)为例。我们可以立刻确认，如果![[公式]](https://www.zhihu.com/equation?tex=n)是奇数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的左半部分；如果![[公式]](https://www.zhihu.com/equation?tex=n)是偶数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的右半部分。如果我们做更多的实验，我们可以发现更多的规律，最终可以指引我们写出一个基于特定曲线的求解对数问题的特定算法。

当然，对数问题也有一些衍生：离散对数问题。这个将在下一篇文章当中进行讨论，如果我们减小椭圆曲线的域，变量乘法依然“简单”，但是离散对数却变成一个“难题”，这个双重特性是椭圆曲线密码学的基石。

### 有限域的椭圆曲线及离散对数问题

* 本文承接上文所讨论的椭圆曲线，并将曲线的定义域从实数域缩小到了有限域，引出离散对数问题
* 首先介绍了有限域的定义，并给出了一种基于模运算的有限域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)
* 然后对离散域上的椭圆曲线重新进行群的构建
* 接着介绍了群的阶数的概念，介绍了计算椭圆曲线上的群的阶数的算法，并讨论群和子群的阶数的联系
* 随后展示了如何用椭圆曲线上的任意一点，通过计算点的倍数的方法，构造一个循环子群
* 最后介绍了一种算法，可以在椭圆曲线上找到一个基点，并通过该基点生成一个阶数为大质数的循环子群

#### 模![[公式]](https://www.zhihu.com/equation?tex=P)的整数域

有限域，顾名思义，就是一个包含有限个元素的集合。一个有限域的具体例子就是模![[公式]](https://www.zhihu.com/equation?tex=p)的整数域，其中![[公式]](https://www.zhihu.com/equation?tex=p)是一个素数。通常它可表示为![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D%2Fp%2CGF%28p%29%2C%5Cmathbb%7BF%7D_p)等，为了简洁，本文采用最后一种符号![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)。

在有限域中，我们有两种二元操作：加法![[公式]](https://www.zhihu.com/equation?tex=%28%2B%29)和乘法![[公式]](https://www.zhihu.com/equation?tex=%28%5Ctimes%29)。两者都满足封闭性、结合律和交换律。对这两个操作，存在独一无二的单位元，且对每一个元素都有一个唯一的逆元。

最后，乘法相对加法满足分配率：![[公式]](https://www.zhihu.com/equation?tex=x%5Ctimes+%28y%2Bz%29%3Dx%5Ctimes+y%2Bx%5Ctimes+z)

模![[公式]](https://www.zhihu.com/equation?tex=p)的整数域是包含所有从0到![[公式]](https://www.zhihu.com/equation?tex=p-1)的整数，即集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)是定义在整数集![[公式]](https://www.zhihu.com/equation?tex=%5C%7B0%2C1%2C2%2C...%2Cp-1%5C%7D)上。在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)上面的加法和乘法以**[模运算（modular arithmetic）](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Modular_arithmetic)**的方式进行工作。下面是一些在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_%7B23%7D)上面的操作实例：

- 加法：![[公式]](https://www.zhihu.com/equation?tex=%2818%2B9%29+%5Cmod+23%3D4)
- 减法：![[公式]](https://www.zhihu.com/equation?tex=%287-14%29+%5Cmod+23+%3D16)
- 乘法：![[公式]](https://www.zhihu.com/equation?tex=4%5Ctimes+7+%5Cmod+23%3D5)
- 加法逆元：![[公式]](https://www.zhihu.com/equation?tex=-5+%5Cmod+23%3D18) 实际上：作为加法群时，其单位元为0，根据![[公式]](https://www.zhihu.com/equation?tex=%285%2B%28-5%29%29+%5Cmod+23+%3D+%285%2B18%29%5Cmod+23%3D0)，有![[公式]](https://www.zhihu.com/equation?tex=-5+%5Cmod+23%3D18)
- 乘法逆元：![[公式]](https://www.zhihu.com/equation?tex=9%5E%7B-1%7D%5Cmod+23%3D18) 实际上：作为乘法群时，其单位元为1，根据![[公式]](https://www.zhihu.com/equation?tex=9%5Ctimes+9%5E%7B-1%7D+%5Cmod+23+%3D+9%5Ctimes+18%5Cmod+%3D+1)，有![[公式]](https://www.zhihu.com/equation?tex=9%5E%7B-1%7D%5Cmod+23%3D18)

正如我们之前所说，整数对![[公式]](https://www.zhihu.com/equation?tex=p)取模后所组成的有限域将具备以上所有性质。不过需要注意的是，![[公式]](https://www.zhihu.com/equation?tex=p)必须是一个质数！否则将无法成为一个域。比如模4整数集就不是一个域：因为2没有乘法逆元，即方程![[公式]](https://www.zhihu.com/equation?tex=2%5Ctimes+x+%5Cmod+4+%3D+1)无解。

#### 模![[公式]](https://www.zhihu.com/equation?tex=p)除法

在完成对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上面对椭圆曲线进行定义之前，我们先来搞搞清楚![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上面![[公式]](https://www.zhihu.com/equation?tex=x%2Fy)意味着什么。本质上，我们可以认为：![[公式]](https://www.zhihu.com/equation?tex=x%2Fy%3Dx%5Ctimes+y%5E%7B-1%7D)，用语言来表示就是![[公式]](https://www.zhihu.com/equation?tex=x) 除以![[公式]](https://www.zhihu.com/equation?tex=y)等价于![[公式]](https://www.zhihu.com/equation?tex=x)乘以![[公式]](https://www.zhihu.com/equation?tex=y)的乘法逆元。这个结果并不意外，且给出了求解除法的基本方法：找到元素的乘法逆元然后再做一个乘法。

利用**[扩展欧几里德算法（Extended Euclidean algorithm）](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Extended_Euclidean_algorithm)**可以“方便”地计算乘法逆元，即便在最坏的情况下，算法的时间复杂度也仅为![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+p%29)，如果考虑![[公式]](https://www.zhihu.com/equation?tex=p)的二进制比特长度为![[公式]](https://www.zhihu.com/equation?tex=k)的话，则为![[公式]](https://www.zhihu.com/equation?tex=O%28k%29)。

现在，我们有足够的必要条件对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线进行定义，前面实数域上的定义如下：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%5Cmathbb%7BR%7D%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb%2C4a%5E3%2B27b%5E2%5Cneq0%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)有限域上的定义如下：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%28%5Cmathbb%7BF%7D_p%29%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb+%5Cpmod%7Bp%7D%2C4a%5E3%2B27b%5E2%5Cnot%5Cequiv0%5Cpmod%7Bp%7D%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

其中0依然是位于无限远的点，![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的两个整数。

![img](https://pic4.zhimg.com/80/v2-dfd9efe44dca23b82a045f839960df1b_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-cdbe8abec7b33dc62d0a96fc34aa019d_720w.jpg)

从几何的角度，图形则从连续的曲线变成![[公式]](https://www.zhihu.com/equation?tex=xy)平面上面的不相连的离散点的集合。好在，我们可以依然证明，即便我们对于定义域进行诸多限制，![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线依然可以组成一个阿贝尔群。

#### 点加法

显然，为了使得点加法在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上依然有效，我们需要对定义作一些小小的修改。对于实数，我们定义三个共线的点之和为0。这个定义可以保留，但是我们需要搞明白在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域中三点共线意味着什么。

在实数域，显然，三点共线意味着能够找到一条直线将三个点连在一起就好。当然，在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域中，直线与实数域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BR%7D)中的是有所不同的。不太严谨地说，![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)中的直线是满足方程![[公式]](https://www.zhihu.com/equation?tex=ax%2Bby%2Bc%5Cequiv+0%5Cpmod%7Bp%7D)的点![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%29)的集合。

![img](https://pic3.zhimg.com/80/v2-2a8d96820cefdc9053bd1ef083b720da_720w.jpg)

假设我们在一个群当中，点加法将保留所有我们已知的特性：

- ![[公式]](https://www.zhihu.com/equation?tex=Q%2B0%3D0%2BQ%3DQ)
- 对于一个非0的点![[公式]](https://www.zhihu.com/equation?tex=Q)，逆元![[公式]](https://www.zhihu.com/equation?tex=-Q)是横坐标相同但是纵坐标相反的点。或者如果你愿意，可以这样计算，![[公式]](https://www.zhihu.com/equation?tex=-Q%3D%28x_Q%2C-y_Q+%5Cmod+p%29)，举个例子，在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_29)域上的曲线有一个点![[公式]](https://www.zhihu.com/equation?tex=Q%3D%282%2C5%29)，则其逆元![[公式]](https://www.zhihu.com/equation?tex=-Q%3D%282%2C-5+%5Cmod+29%29%3D%282%2C24%29)
- 根据逆元的定义有![[公式]](https://www.zhihu.com/equation?tex=P%2B%28-P%29%3D0)

除了在每一个表达式后面加上一个![[公式]](https://www.zhihu.com/equation?tex=%5Cmod+p)的操作以外其它与前一篇文章当中所描述的步骤都相同。因此，令![[公式]](https://www.zhihu.com/equation?tex=P%3D%28x_P%2Cy_p%29%2CQ%3D%28x_Q%2Cy_Q%29%2CR%3D%28x_R%2Cy_R%29)，我们可以按如下方程计算![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R)：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_R%26%3D%28m%5E2-x_P-x_Q%29%5Cmod%5C%2C+p%5C%5C+y_R%26%3D%5By_P%2Bm%28x_R-x_P%29%5D%5Cmod%5C%2C+p%5C%5C+%26%3D%5By_Q%2Bm%28x_R-x_Q%29%5D%5Cmod%5C%2C+p+%5Cend%7Balign%7D+%5C%5C)

如果![[公式]](https://www.zhihu.com/equation?tex=P%5Cneq+Q)，斜率![[公式]](https://www.zhihu.com/equation?tex=m)的形式如下：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%28y_P-y_Q%29%7B%28x_P-x_Q%29%7D%5E%7B-1%7D%5Cmod%5C%2Cp+%5C%5C)

如果![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)，则有：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%283x%5E2_P%2Ba%29%282y_P%29%5E%7B-1%7D%5Cmod%5C%2Cp+%5C%5C)

方程形式的一致并不是巧合：实际上在任何一个域，方程的形式都是相同的，有限的或者无限的，仅在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_2)和 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_3)两个特定域上不成立。关于数学上的证明有兴趣的话可以参阅**[proof from Stefan Friedl](https://link.zhihu.com/?target=http%3A//math.rice.edu/~friedl/papers/AAELLIPTIC.PDF)**

另外，考虑到离散化后的曲线切线已无从谈起，以及其它方面的一些问题，在离散化域中，我们不再定义几何加法。

#### 椭圆曲线群的阶

显而易见，有限域上定义的椭圆曲线只有有限个点。但是有一个重要的问题不应该忽略：对于一个特定有限域上的椭圆曲线，到底有多少个点呢？

首先，我们将群中所包含点的数目定义为**群的阶**。

通常从![[公式]](https://www.zhihu.com/equation?tex=x)到 ![[公式]](https://www.zhihu.com/equation?tex=p-1)进行暴力枚举不是一个可行的方式，这个需要![[公式]](https://www.zhihu.com/equation?tex=O%28p%29)的步骤，如果![[公式]](https://www.zhihu.com/equation?tex=p)是一个很大的质数，这将是一个难题。

所幸，有一个更快的算法可以计算群的阶：**[Schoof's algorithm](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Schoof%27s_algorithm)**，这个算法可以在多项式级别的算法世界复杂度内，这正是我们所需要的。

#### 标量乘法与循环子群

![[公式]](https://www.zhihu.com/equation?tex=nP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D+%5C%5C)

这次我们依然可以使用**[翻倍累加算法](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/%23double-and-add)**将乘法计算的时间复杂度控制在![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)。

在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线进行乘法有一个有趣的性质。以曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%5Cequiv+x%5E3%2B2x%2B3%28%5Cmod%5C%2C97%29)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%283%2C6%29)为例，**[计算](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/modk-mul.html)**![[公式]](https://www.zhihu.com/equation?tex=P)的所有乘积：

![img](https://pic1.zhimg.com/80/v2-abb286db1834b321327a4f14ea2ac2f4_720w.jpg)

- ![[公式]](https://www.zhihu.com/equation?tex=0P%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=1P%3D%283%2C6%29)
- ![[公式]](https://www.zhihu.com/equation?tex=2P%3D%2880%2C10%29)
- ![[公式]](https://www.zhihu.com/equation?tex=3P%3D%2880%2C87%29)
- ![[公式]](https://www.zhihu.com/equation?tex=4P%3D%283%2C91%29)
- ![[公式]](https://www.zhihu.com/equation?tex=5P%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=6P%3D%283%2C6%29)
- ![[公式]](https://www.zhihu.com/equation?tex=7P%3D%2880%2C10%29)
- ![[公式]](https://www.zhihu.com/equation?tex=8P%3D%2880%2C87%29)
- ![[公式]](https://www.zhihu.com/equation?tex=9P%3D%283%2C91%29)
- ...

在此，我们可以确认两件事情：第一，![[公式]](https://www.zhihu.com/equation?tex=P)的乘积只有五种可能答案：椭圆曲线上面的其它的点决不会出现；第二，这五个点循环出现。我们可以这样写：

- ![[公式]](https://www.zhihu.com/equation?tex=5kP%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B1%29P%3DP)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B2%29P%3D2P)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B3%29P%3D3P)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B4%29P%3D4P)

对于每一个整数![[公式]](https://www.zhihu.com/equation?tex=k)，上述5个方程可以借助模运算符压缩成一个方程：![[公式]](https://www.zhihu.com/equation?tex=kP%3D%28k%5Cmod%5C%2C5%29P)

不仅如此，我们可以立刻确认这五个点在加法操作上面也是封闭的。这意味着：不管我是加![[公式]](https://www.zhihu.com/equation?tex=0%2CP%2C2P%2C3P%2C4P)中的哪一个，结果都是上述五个点之一，其它的点依然不会出现在结果当中。

不仅仅对于![[公式]](https://www.zhihu.com/equation?tex=P%3D%283%2C6%29)，对于任何点都有这样的结果。如果我们假设一个通用的点![[公式]](https://www.zhihu.com/equation?tex=P)：

![[公式]](https://www.zhihu.com/equation?tex=nP%2BmP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D%2B%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D%3D%28n%2Bm%29P+%5C%5C)

这意味着：如果我们将两个![[公式]](https://www.zhihu.com/equation?tex=P)的乘积相加，我们将得到一个![[公式]](https://www.zhihu.com/equation?tex=P)的乘积，![[公式]](https://www.zhihu.com/equation?tex=P)的乘积在加法操作下是封闭的。

这足以证明![[公式]](https://www.zhihu.com/equation?tex=P)的乘积的集合是一个由椭圆曲线所组成的群的循环子群（cyclic subgroup）。

一个“子群”是指另外一个群的子集的群。而“循环子群”则是指子群中的元素循环地出现，就好像在前面的例子当中所示。点![[公式]](https://www.zhihu.com/equation?tex=P)被称为*发生器（generator）或者基点（base point）*。

循环子群是椭圆曲线密码学以及其它加密系统的基础。

#### 子群的阶

我们可以自问一下：由一个点![[公式]](https://www.zhihu.com/equation?tex=P)产生的子群的阶（order）是多少，或者也可以称之为![[公式]](https://www.zhihu.com/equation?tex=P)的阶。回答这个问题无法使用`Schoof's algorithm`，因为该算法只有在整个椭圆曲线上面是有效的，在子群当中就无效了。在解决这个问题之前，我们需要了解以下几点：

- 我们已经对群的阶进行过定义：阶是一个群的点数。目前这个定义依然有效，但是在一个循环子群当中，我们可以给一个新的等价的定义：循环子群的阶是使得![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的最小正整数![[公式]](https://www.zhihu.com/equation?tex=n)。我们可以看之前那个例子，我们的子群有5个点，然后我们有![[公式]](https://www.zhihu.com/equation?tex=5P%3D0)
- **[Lagrange's theorem](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory))**，![[公式]](https://www.zhihu.com/equation?tex=P)的阶与椭圆曲线本身的阶有联系，一个子群的阶是父群阶的一个因子。换句话说，如果一个椭圆曲线有![[公式]](https://www.zhihu.com/equation?tex=N)个点，然后它的一个子群有![[公式]](https://www.zhihu.com/equation?tex=n)个点，那么![[公式]](https://www.zhihu.com/equation?tex=n)是 ![[公式]](https://www.zhihu.com/equation?tex=N)的一个因子

以上两个有用的信息合在一起可以帮助我们找到基于特定几点![[公式]](https://www.zhihu.com/equation?tex=P)的子群的阶：

- 使用`Schoof's algorithm`找到椭圆曲线而阶![[公式]](https://www.zhihu.com/equation?tex=N)
- 找到![[公式]](https://www.zhihu.com/equation?tex=N)的所有因子
- 对![[公式]](https://www.zhihu.com/equation?tex=N)的每一个因子![[公式]](https://www.zhihu.com/equation?tex=n)，都计算![[公式]](https://www.zhihu.com/equation?tex=nP)
- 满足![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的最小正整数![[公式]](https://www.zhihu.com/equation?tex=n)，就是子群的阶

举个例子，曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-x%2B3)在域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_37)(F/37，显示问题)上的阶为![[公式]](https://www.zhihu.com/equation?tex=N%3D42)，则其子群可能的阶为![[公式]](https://www.zhihu.com/equation?tex=n%3D1%2C2%2C3%2C6%2C7%2C14%2C21%2C42)。如果我们选取基点![[公式]](https://www.zhihu.com/equation?tex=P%3D%282%2C3%29)，我们可以发现![[公式]](https://www.zhihu.com/equation?tex=P%5Cneq+0%2C2P%5Cneq+0%2C...%2C7P%3D0)，因此基点![[公式]](https://www.zhihu.com/equation?tex=P)的阶为![[公式]](https://www.zhihu.com/equation?tex=n%3D7)。

需要特别注意的是，选取最小的因子非常重要，而不是随机选取。如果随机选取，我们还可能选择![[公式]](https://www.zhihu.com/equation?tex=n%3D14)，虽然![[公式]](https://www.zhihu.com/equation?tex=n%3D14)是满足![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的，但是它并不是子群的阶，而且其中的一个乘数。

再举一个例子，曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-x%2B3)在域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_29)上的阶为![[公式]](https://www.zhihu.com/equation?tex=N%3D37)，是一个素数，其子群可能的阶仅为![[公式]](https://www.zhihu.com/equation?tex=n%3D1%2C37)。不难猜到，当![[公式]](https://www.zhihu.com/equation?tex=n%3D1)时，子群只包含一个在无限远的点；当![[公式]](https://www.zhihu.com/equation?tex=n%3DN%3D37)时，子群包含椭圆曲线上面所有的点。

#### 寻找一个基点

对于我们的椭圆曲线加密算法，我们需要一个尽量高阶的子群。通常来说，我们选择一条椭圆曲线，计算它的阶（![[公式]](https://www.zhihu.com/equation?tex=N)），确定一个比较大的因子作为子群的阶（![[公式]](https://www.zhihu.com/equation?tex=n)），然后据此寻找一个合适的基点。下面来看看我们是如何先确定子群的阶再匹配合适的基点，而不是先找基点再计算子群的阶的。

首先，需要再介绍一个概念。**[Lagrange's theorem](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory))**表明![[公式]](https://www.zhihu.com/equation?tex=h%3DN%2Fn)一定是一个整数。![[公式]](https://www.zhihu.com/equation?tex=h)被称为子群的协因子（cofactor）。

对于椭圆曲线上面的每一个点，我们有![[公式]](https://www.zhihu.com/equation?tex=NP%3D0)，根据协因子的定义，我们有![[公式]](https://www.zhihu.com/equation?tex=n%28hP%29%3D0)。

现在假设![[公式]](https://www.zhihu.com/equation?tex=n)是一个素数，那么这个方程告诉我们点![[公式]](https://www.zhihu.com/equation?tex=G%3DhP)可以产出一个阶为![[公式]](https://www.zhihu.com/equation?tex=n)的子群。

综上所述，通过确定子群的阶，再据此寻找合适的基点的算法如下：

- 计算椭圆曲线的阶![[公式]](https://www.zhihu.com/equation?tex=N)
- 选择恰当的子群的阶![[公式]](https://www.zhihu.com/equation?tex=n)，为了使得这个算法能够正常工作，这个整数必须是素数，并且是![[公式]](https://www.zhihu.com/equation?tex=N)的一个因子
- 计算协因子![[公式]](https://www.zhihu.com/equation?tex=h%3DN%2Fn)
- 再曲线上面选择一个随机点![[公式]](https://www.zhihu.com/equation?tex=P)
- 计算![[公式]](https://www.zhihu.com/equation?tex=G%3DhP)
- 如果![[公式]](https://www.zhihu.com/equation?tex=G)是0，则返回第四步，否则，我们就找到了一个阶为![[公式]](https://www.zhihu.com/equation?tex=n)且协因子为![[公式]](https://www.zhihu.com/equation?tex=h)的子群

需要指出的是该算法当且仅当![[公式]](https://www.zhihu.com/equation?tex=n)是素数的时候才能够正常工作，如果![[公式]](https://www.zhihu.com/equation?tex=n)不是一个素数，则![[公式]](https://www.zhihu.com/equation?tex=G)的阶会是![[公式]](https://www.zhihu.com/equation?tex=n)的一个因子。

#### 离散对数

正如我们再之前那篇文章当中对连续的椭圆曲线所做的，对于定义在离散域当中的椭圆曲线，我们接下来讨论一下下面这个问题：如果已知![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，如果求得满足![[公式]](https://www.zhihu.com/equation?tex=Q%3DkP)的 ![[公式]](https://www.zhihu.com/equation?tex=k)呢？

这个问题，就是经典的椭圆曲线*离散对数问题*，通常来说是“hard”的问题，在经典的计算机上面是无法通过多项式级别的时间复杂度来解决这个问题的，尽管目前还没有严格的数学证明。

这个问题和其它加密系统当中使用的离散对数问题类似，比如`DSA`，`D-H`和`ElGamal`。这并不是一个巧合。不同的是，在这些算法当中，我们使用幂模运算来代替标量乘法。这些离散对数问题可以表示如下： 已知![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)，求满足![[公式]](https://www.zhihu.com/equation?tex=b%3Da%5Ek+%5Cmod+p)

两个问题都是离散的，因为它只与有限的集合相关，更加精确地说，是循环子群。而当前椭圆曲线加密更为有趣是在于它比起其它类似的加密系统难题更难，可以使用更小的字节来表示整数![[公式]](https://www.zhihu.com/equation?tex=k)来获得的安全级别。







## 参考：

* [知乎Datacruiser](https://www.zhihu.com/column/datacruiser)

## 参考资料

- **[Elliptic Curve Cryptography: a gentle introduction](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction)**
- **[wiki百科-群](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%BE%A4)**
- **[区块链理论与方法](https://link.zhihu.com/?target=https%3A//item.jd.com/12782144.html)**
- **[wiki百科-椭圆曲线](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF)**
- **[Elliptic_Curve](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Elliptic_curve)**

- **[扩展欧几里德算法（Extended Euclidean algorithm）](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Extended_Euclidean_algorithm)**
- **[模运算（modular arithmetic）](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Modular_arithmetic)**
- **[Khan Academy](https://link.zhihu.com/?target=https%3A//www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic)**
- **[Elliptic Curve Cryptography: finite fields and discrete logarithms](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/)**
- **[有限域和离散对数问题(ECC椭圆曲线算法2)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/mrpre/article/details/72850598)**