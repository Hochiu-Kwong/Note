

# 密码学学习

**2020.10.14**

***

## SHA256 算法原理及介绍 

### SHA-2 族算法简介

* 一个`n`位的哈希函数就是一个从任意长的消息到`n`位哈希值的映射，一个`n`位的加密哈希函数就是一个单向的、避免碰撞的`n`位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。

### SHA256原理详解

#### 简介

* 对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。
* 例子：`blockchain` 的SHA-256具有如下哈希值
* `3a6fed5fc11392b3ee9f81caf017b48640d7458766a8eb0382899a605b41f2b9`
* 总体上，HSA256与MD4、MD5以及HSA-1等哈希函数的操作流程类似，待哈希的消息在继续哈希计算之前首先要进行以下两个步骤：
* 对消息进行补位处理，是的最终的长度是512位的倍数，然后
* 以512位为单位对消息进行分块为![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D)
* 消息区块将进行逐个处理：从一个固定的初始哈希![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)开始，进行以下序列的计算：
* ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D%3DH%5E%7B%28i-1%29%7D%2BC_%7BM%5E%7B%28i%29%7D+%7D%28H%5E%7B%28i-1%29%7D%29+%5C%5C)

#### 常量初始化

* 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位

* ![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7B2%7D)小数部分约为0.414213562373095048

* ![[公式]](https://www.zhihu.com/equation?tex=0.414213562373095048+%5Capprox+6%2A16%5E%7B-1%7D%2Ba%2A16%5E%7B-2%7D%2B0%2A16%5E%7B-3%7D%2B...+%5C%5C)

* 于是, 质数2的平方根的小数部分取前32位就对应`0x6a09e667`

* 如此类推, 初始哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%280%29%7D)由以下8个32位的哈希初值构成:

  ![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%280%29%7D_1%26%3D6a09e667%5C%5C+H%5E%7B%280%29%7D_2%26%3Dbb67ae85%5C%5C+H%5E%7B%280%29%7D_3%26%3D3c6ef372%5C%5C+H%5E%7B%280%29%7D_4%26%3Da54ff53a%5C%5C+H%5E%7B%280%29%7D_5%26%3D510e527f%5C%5C+H%5E%7B%280%29%7D_6%26%3D9b05688c%5C%5C+H%5E%7B%280%29%7D_7%26%3D1f83d9ab%5C%5C+H%5E%7B%280%29%7D_8%26%3D5be0cd19+%5Cend%7Balign%7D+%5C%5C)

* SHA256算法当中还使用到64个常数, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下

* ```text
  428a2f98 71374491 b5c0fbcf e9b5dba5
  3956c25b 59f111f1 923f82a4 ab1c5ed5
  d807aa98 12835b01 243185be 550c7dc3
  72be5d74 80deb1fe 9bdc06a7 c19bf174
  e49b69c1 efbe4786 0fc19dc6 240ca1cc
  2de92c6f 4a7484aa 5cb0a9dc 76f988da
  983e5152 a831c66d b00327c8 bf597fc7
  c6e00bf3 d5a79147 06ca6351 14292967
  27b70a85 2e1b2138 4d2c6dfc 53380d13
  650a7354 766a0abb 81c2c92e 92722c85
  a2bfe8a1 a81a664b c24b8b70 c76c51a3
  d192e819 d6990624 f40e3585 106aa070
  19a4c116 1e376c08 2748774c 34b0bcb5
  391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
  748f82ee 78a5636f 84c87814 8cc70208
  90befffa a4506ceb bef9a3f7 c67178f2
  ```

#### 消息预处理

* 在计算消息的哈希摘要之前需要对消息进行预处理:

* 对消息进行补码处理: 假设消息![[公式]](https://www.zhihu.com/equation?tex=M)的二进制编码长度为![[公式]](https://www.zhihu.com/equation?tex=l)位. 首先在消息末尾补上一位"1", 然后再补上![[公式]](https://www.zhihu.com/equation?tex=k)个"0", 其中![[公式]](https://www.zhihu.com/equation?tex=k)为下列方程的最小非负整数

* ![[公式]](https://www.zhihu.com/equation?tex=l%2B1%2Bk%5Cequiv448%5Cmod+512+%5C%5C)

* 举个例子, 以消息"abc"为例显示补位的过程.

  a,b,c对应的**[ASCII码](https://link.zhihu.com/?target=http%3A//ascii.911cha.com/)**和二进制编码分别如下:

  ```text
  原始字符    ASCII码    二进制编码
  a          97         01100001
  b          98         01100010
  c          99         01100011
  ```

* 因此, 原始信息"abc"的二进制编码为:`01100001 01100010 01100011`, 第一步补位, 首先在消息末尾补上一位"1", 结果为: `01100001 01100010 01100011 1`; 然后进行第二步的补位, 因为![[公式]](https://www.zhihu.com/equation?tex=l%3D24), 可以得到![[公式]](https://www.zhihu.com/equation?tex=k%3D423), 在第一步补位后的消息后面再补423个"0", 结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D+%5C%5C)

* 最后还需要在上述字节串后面继续进行补码, 这个时候补的是原消息"abc"的二进制长度![[公式]](https://www.zhihu.com/equation?tex=l%3D24)的64位二进制表示形式, 补完以后的结果如下:

* ![[公式]](https://www.zhihu.com/equation?tex=01100001+%5C%2C+01100010+%5C%2C+01100011+%5C%2C1%5C%2C+%5Cunderbrace%7B00...0%7D_%7B423%7D%5C%2C%5Cunderbrace%7B00...011000%7D_%7B64%7D+%5C%5C)

* 最终补完以后的消息二进制位数长度是512的倍数

* 这里需要注意的两点是不管原来的消息长度是多少, 即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位. 另外, 考虑到最后要将消息长度![[公式]](https://www.zhihu.com/equation?tex=l)转换为64位二进制编码, 因此, 长度的必须小于![[公式]](https://www.zhihu.com/equation?tex=2%5E%7B64%7D), 绝大多数情况, 这个足够大了

* 将补码处理后的消息以512位为单位分块为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%281%29%7D%2C%5C%2CM%5E%7B%282%29%7D%2C...%2CM%5E%7B%28N%29%7D), 其中第![[公式]](https://www.zhihu.com/equation?tex=i)个消息块的前32位表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_0), 后面32位为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_1), 以此类推, 最后32位的消息块可表示为: ![[公式]](https://www.zhihu.com/equation?tex=M%5E%7B%28i%29%7D_%7B15%7D). 我们采用Big endian约定对数据进行编码, 即认为第一个字节是最高位字节, 因此, 对于每一个32位字节, 最最左边的比特是最大的比特位

#### 摘要计算主循环

哈希计算算法如下:

- ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+i+%3D+1+%5Cto+N) (![[公式]](https://www.zhihu.com/equation?tex=N) = 补码后消息块个数)

- - 用第![[公式]](https://www.zhihu.com/equation?tex=+%28i+-+1%29)个中间哈希值来对 ![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc%2Cd%2Ce%2Cf%2Cg%2Ch)进行初始化, 当![[公式]](https://www.zhihu.com/equation?tex=i%3D1)时, 就使用初始化哈希, 即:

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+a%26%5Cgets+H%5E%7B%28i-1%29%7D_1%5C%5C+b%26%5Cgets+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+h%26%5Cgets+H%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- 应用SHA256压缩函数来更新![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2C...%2Ch)

- - ![[公式]](https://www.zhihu.com/equation?tex=For%5C%2C+j+%3D+0+%5Cto+63)

  - - 计算![[公式]](https://www.zhihu.com/equation?tex=Ch%28e%2Cf%2Cg%29%2C+M_%7Baj%7D%28a%2Cb%2Cc%29%2C+%5CSigma_0%28a%29%2C+%5CSigma_1%28e%29%2C+W_j)(具体定义如下)
    - PS：对于每一块M，将块分解为16个32-bit的big-endian的字，记为w[0], …, w[15]，其余的字由如下迭代公式得到：
    - ![[公式]](https://www.zhihu.com/equation?tex=W_j%5Cgets+%5Csigma_1%28W_%7Bj-2%7D%29%2BW_%7Bj-7%7D%2B%5Csigma_0%28W_%7Bj-15%7D%29%2BW_%7Bj-16%7D)
    - 进行下面运算

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+T_1+%26%5Cgets+h%2B%5CSigma_1%28e%29%2BCh%28e%2Cf%2Cg%29%2BK_j%2BW_j%5C%5C+T_2%26%5Cgets+%5CSigma_0%28a%29%2BM_%7Baj%7D%28a%2Cb%2Cc%29%5C%5C+h%26%5Cgets+g%5C%5C+g%26%5Cgets+f%5C%5C+f%26%5Cgets+e%5C%5C+e%26%5Cgets+d%2BT_1%5C%5C+d%26%5Cgets+c%5C%5C+c%26%5Cgets+b%5C%5C+b%26%5Cgets+a%5C%5C+a%26%5Cgets+T_1%2BT_2+%5Cend%7Balign%7D+%5C%5C)

- 计算第![[公式]](https://www.zhihu.com/equation?tex=i)个中间哈希值![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28i%29%7D)

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+H%5E%7B%28i%29%7D_1+%26%5Cgets+a+%2B+H%5E%7B%28i-1%29%7D_1%5C%5C+H%5E%7B%28i%29%7D_2+%26%5Cgets+b%2B+H%5E%7B%28i-1%29%7D_2%5C%5C+%26%5Cvdots%5C%5C+H%5E%7B%28i%29%7D_8+%26%5Cgets+h%2BH%5E%7B%28i-1%29%7D_8+%5Cend%7Balign%7D+%5C%5C)

- ![[公式]](https://www.zhihu.com/equation?tex=H%5E%7B%28N%29%7D%3D%28H%5E%7B%28N%29%7D_1%2CH%5E%7B%28N%29%7D_2%2C...%2CH%5E%7B%28N%29%7D_8%29)为最终需要的哈希![[公式]](https://www.zhihu.com/equation?tex=M)。



### SHA伪代码

```text
Note 1: All variables are 32 bit unsigned integers and addition is calculated modulo 232
Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 ≤ i ≤ 63
Note 3: The compression function uses 8 working variables, a through h
Note 4: Big-endian convention is used when expressing the constants in this pseudocode,
    and when parsing message block data from bytes to words, for example,
    the first word of the input message "abc" after padding is 0x61626380

Initialize hash values:
(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
h0 := 0x6a09e667
h1 := 0xbb67ae85
h2 := 0x3c6ef372
h3 := 0xa54ff53a
h4 := 0x510e527f
h5 := 0x9b05688c
h6 := 0x1f83d9ab
h7 := 0x5be0cd19

Initialize array of round constants:
(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
k[0..63] :=
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

Pre-processing (Padding):
begin with the original message of length L bits
append a single '1' bit
append K '0' bits, where K is the minimum number >= 0 such that L + 1 + K + 64 is a multiple of 512
append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits

Process the message in successive 512-bit chunks:
break message into 512-bit chunks
for each chunk
    create a 64-entry message schedule array w[0..63] of 32-bit words
    (The initial values in w[0..63] don't matter, so many implementations zero them here)
    copy chunk into first 16 words w[0..15] of the message schedule array

    Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
    for i from 16 to 63
        s0 := (w[i-15] rightrotate  7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift  3)
        s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10)
        w[i] := w[i-16] + s0 + w[i-7] + s1

    Initialize working variables to current hash value:
    a := h0
    b := h1
    c := h2
    d := h3
    e := h4
    f := h5
    g := h6
    h := h7

    Compression function main loop:
    for i from 0 to 63
        S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
        ch := (e and f) xor ((not e) and g)
        temp1 := h + S1 + ch + k[i] + w[i]
        S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
        maj := (a and b) xor (a and c) xor (b and c)
        temp2 := S0 + maj
 
        h := g
        g := f
        f := e
        e := d + temp1
        d := c
        c := b
        b := a
        a := temp1 + temp2

    Add the compressed chunk to the current hash value:
    h0 := h0 + a
    h1 := h1 + b
    h2 := h2 + c
    h3 := h3 + d
    h4 := h4 + e
    h5 := h5 + f
    h6 := h6 + g
    h7 := h7 + h

Produce the final hash value (big-endian):
digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7
```



## 椭圆曲线密码学学习

### 椭圆曲线（Elliptic Curves）

#### 什么是椭圆曲线

而ECC算法所采用的椭圆曲线是一类可用Weierstrass公式加以描述的椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=E)

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%2BA_1+y%3Dx%5E3%2BA_2+x%5E2+%2BA_3x+%2B+A_4%5C%7D+%5C%5C)

其中参数![[公式]](https://www.zhihu.com/equation?tex=A_1)至 ![[公式]](https://www.zhihu.com/equation?tex=A_2)的不同取值决定椭圆曲线在坐标系中的形状。实际常用的形式是一类称为Weierstrass Normal Form（WNF）的的简化形式，即：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29%7Cy%5E2%3Dx%5E3%2Bax+%2B+b%5C%7D+%5C%5C)

由于ECC算法运算过程中需要使用WMF曲线的切线，因此为了使WNF曲线没有奇异点，即处处光滑可导，需要满足其判别式不为零，即：

![[公式]](https://www.zhihu.com/equation?tex=%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq+0+%5C%5C)

同时，定义射影平面上的无穷远点，记为0.无穷远点是所有曲线在无穷远处的交点，也被称为理想点。因此，下面的论述当中所采用的完整的WNF椭圆曲线公式为：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%5Cmathbb%7BR%7D%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb%2C%5CDelta%3D4a%5E3%2B27b%5E2%5Cneq0%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

当令![[公式]](https://www.zhihu.com/equation?tex=b%3D1)， ![[公式]](https://www.zhihu.com/equation?tex=a)从2递减1到-3的椭圆曲线如下所示：

![img](https://pic2.zhimg.com/80/v2-8d9e8ac56d444a7da4a42f25944e8e89_720w.jpg)

下面我们再来看两条存在奇异点的曲线，如下图所示：

![img](https://pic4.zhimg.com/80/v2-495147cc4f70c1772376ffc339e314a7_720w.jpg)

左边这条曲线的方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3)，右边的这条曲线方程为![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B2)，两者都不是合格可用的椭圆曲线。另外，不难发现，所有的椭圆曲线都是关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的。

#### 群论

从数学的角度，一个群是由一种集合以及定义在该群上的一个二元运算所组成，且符合“群公理”。具体完整的定义如下：假设![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)是一个非空集合，![[公式]](https://www.zhihu.com/equation?tex=%2B)是它的一个二元运算，如果满足以下条件，则![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)和 ![[公式]](https://www.zhihu.com/equation?tex=%2B)构成一个群。

- 封闭性（closure）：若![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)是集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)的成员，则存在唯一确定的![[公式]](https://www.zhihu.com/equation?tex=c+%5Cin+%5Cmathbb%7BG%7D)，使得![[公式]](https://www.zhihu.com/equation?tex=c%3Da%2Bb)
- 结合律（associativity）：即对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中任意元素![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2Cc)，都有![[公式]](https://www.zhihu.com/equation?tex=%28a%2Bb%29%2Bc%3Da%2B%28b%2Bc%29)
- 单位元（identify element）：存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=e) ，对任意所有的![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的元素![[公式]](https://www.zhihu.com/equation?tex=a)，总有等式![[公式]](https://www.zhihu.com/equation?tex=e%2Ba%3Da%2Be%3Da)。则将![[公式]](https://www.zhihu.com/equation?tex=e)称为单位元，也称幺元
- 逆元（inverse）：对于![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)任意一个![[公式]](https://www.zhihu.com/equation?tex=a)，存在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BG%7D)中的一个元素![[公式]](https://www.zhihu.com/equation?tex=b)，使得总有![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba%3De)（![[公式]](https://www.zhihu.com/equation?tex=e)为单位元），则称![[公式]](https://www.zhihu.com/equation?tex=a)与 ![[公式]](https://www.zhihu.com/equation?tex=b) 互为逆元素，简称逆元。![[公式]](https://www.zhihu.com/equation?tex=b) 记作![[公式]](https://www.zhihu.com/equation?tex=a%5E%7B-1%7D)

群运算的次序很重要，把元素![[公式]](https://www.zhihu.com/equation?tex=a) 与元素![[公式]](https://www.zhihu.com/equation?tex=b)结合，所得到的结果不一定与把元素![[公式]](https://www.zhihu.com/equation?tex=b)与元素![[公式]](https://www.zhihu.com/equation?tex=a)结合相同；亦即，![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3Db%2Ba)（交换律）不一定恒成立。满足交换律的群称为交换群（阿贝尔群，以尼尔斯·阿贝尔命名），不满足交换律的群称为非交换群（非阿贝尔群）。

如果我们将加法作为集合的二元运算，那么加上整数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D)将得到一个群，且是一个阿贝尔群。而自然数集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D)因为不满足逆元，则无法与加法构成一个群。

群的奇妙之处在于如果你能够上述四个性质，那么你可以获得一些其它有趣的性质。

比如，单位元是独一无二的，逆元也是独一无二的。对于任何一个![[公式]](https://www.zhihu.com/equation?tex=a)，有且仅有一个![[公式]](https://www.zhihu.com/equation?tex=b)满足![[公式]](https://www.zhihu.com/equation?tex=a%2Bb%3D0)。

#### 椭圆曲线的群法则

- 群的元素是椭圆曲线上面的点的集合
- 单位元是在无穷远处的点，记为0
- 一个元素点![[公式]](https://www.zhihu.com/equation?tex=P)的逆元是其关于![[公式]](https://www.zhihu.com/equation?tex=x)轴对称的点
- 二元远算操作规则定义如下：在曲线上面找到对齐的在一条直线上面的三个非零的点：![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)，三者之和为0，即![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)

![img](https://pic1.zhimg.com/80/v2-7cbef44d3018bd390d0ea6fa61f3af48_720w.jpg)

对于最后一点，我们的要求仅仅是一条直线上面对齐的三个点，而对齐本身与顺序是无关的，因此，如果![[公式]](https://www.zhihu.com/equation?tex=P%2C+Q%2C+R)是对齐的，则有![[公式]](https://www.zhihu.com/equation?tex=P%2B%28Q%2BR%29%3DQ%2B%28P%2BR%29%3DR%2B%28P%2BQ%29%3D...%3D0)，如此这般，我们也顺带证明了我们所定义的二元操作符是能够同时满足结合律和交换律的，我们在椭圆曲线上面定义的群还是一个阿贝尔群。

#### 几何加法

庆幸我们是在一个阿贝尔群当中，我们可以将![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%2BR%3D0)写成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R)。这个形式的方程，可以让我们得到一种计算两个点![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)相加之和的几何方法：如果我们画一条直线通过![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，那么直线会与曲线相交与第三个点![[公式]](https://www.zhihu.com/equation?tex=R)。那么该点的逆元![[公式]](https://www.zhihu.com/equation?tex=-R)即为![[公式]](https://www.zhihu.com/equation?tex=P%2BQ)的结果。

![img](https://pic1.zhimg.com/80/v2-0ed62d5d6ac021ee2a0e0c3ccfce9c54_720w.jpg)

几何方法一目了然，但是还需要回答一些边界条件：

- ![[公式]](https://www.zhihu.com/equation?tex=P%3D0+%5C%2C+or%5C%2C+Q%3D0)：考虑到无穷远点本身并不在这个平面上面，线是画不出来的，但是我们已经定义了0为单位元，对于任意![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，都有![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3DP%E5%92%8C0%2BQ%3DQ)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3D-Q)：经过这两个点的直线是一条垂直线，与椭圆曲线不会有第三个交点。但是![[公式]](https://www.zhihu.com/equation?tex=P)是 ![[公式]](https://www.zhihu.com/equation?tex=Q)的逆元，根据逆元的定义有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3DP%2B%28-P%29%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)：会有无数条线经过这个点，情况会有一些复杂。令![[公式]](https://www.zhihu.com/equation?tex=Q%27%5Cneq+P)，如果我们让![[公式]](https://www.zhihu.com/equation?tex=Q%27)无限得接近![[公式]](https://www.zhihu.com/equation?tex=P)，则经过它们的直线会变成椭圆曲线的切线，此时有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R)，其中![[公式]](https://www.zhihu.com/equation?tex=R)是切线与椭圆曲线的交点。如下图所示：

![img](https://pic2.zhimg.com/v2-91b444e4c0e4c386495cb359b064c655_b.webp)

![[公式]](https://www.zhihu.com/equation?tex=P+%5Cneq+Q)，且找不到第三点![[公式]](https://www.zhihu.com/equation?tex=R)：这个情况与上面的情况非常类似，此时过![[公式]](https://www.zhihu.com/equation?tex=P%2CQ)的线就是椭圆曲线的切线。假设![[公式]](https://www.zhihu.com/equation?tex=P)就是切点，在前面的一个情况当中，![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-Q)，这个方程现在变成![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-P)。反过来，如果![[公式]](https://www.zhihu.com/equation?tex=Q)是这个切点，则有![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-Q)。如下图所示：

![img](https://pic2.zhimg.com/v2-ba1669a982efc7cd7786c74c372dfecd_b.webp)



现在几何加法已经能够覆盖所有的情况了，你只需要尺规就可以在椭圆曲线上面进行各种加法计算了。如果有兴趣也可以看看本文主要参考资料作者提供的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，这个工具提供了在实数域和离散有限域上面的加法和乘法实现，可以直观的看出这两者的区别，便于对文章的理解。

#### 代数加法

如果要使用计算机进行具体的加法远算，那么要从几何方法切换到代数方法。将以上所描述的规则转化为方程组是直截了当的办法，但是因为涉及到求解三次方程，会非常麻烦，这里仅仅给出最终结果，具体的求解和推导过程可以查阅相关资料，比如wiki百科等。

首先，对于简单的边界条件先排除掉，我们已经知道![[公式]](https://www.zhihu.com/equation?tex=P%2B%28-P%29%3D0)，以及![[公式]](https://www.zhihu.com/equation?tex=P%2B0%3D0%2BP%3DP)。因此，我们只需要考虑两个非零且不对称的点![[公式]](https://www.zhihu.com/equation?tex=P%3D%28x_P%2Cy_P%29%2CQ%3D%28x_Q%2Cy_Q%29)。

如果![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)不相等，则通过这两个点的直线的斜率为：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D+%5C%5C)

则直线与椭圆曲线的第三个交点![[公式]](https://www.zhihu.com/equation?tex=R%28x_R%2Cy_R%29)的坐标如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_R%26%3Dm%5E2-x_P-x_Q%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29+%5Cend%7Balign%7D+%5C%5C)

或者，等价于：

![[公式]](https://www.zhihu.com/equation?tex=y_R%3Dy_Q%2Bm%28x_R-x_Q%29+%5C%5C)

因此有：![[公式]](https://www.zhihu.com/equation?tex=%28x_P%2Cy_P%29%2B%28x_Q%2Cy_Q%29%3D%28x_R%2C-y_R%29)，需要注意![[公式]](https://www.zhihu.com/equation?tex=y_R)的负号。

为了验证结果的正确性，需要验证以下两点：

- ![[公式]](https://www.zhihu.com/equation?tex=R)是否在这条曲线上面
- ![[公式]](https://www.zhihu.com/equation?tex=P%2CQ%2CR)是否共线

验证三点是否共线相对简单，而验证一个点是否在椭圆曲线上面则相对复杂一些，需要求解三次方程。这里我们还是借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**，在曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-7x%2B10)上面取两点![[公式]](https://www.zhihu.com/equation?tex=P%3D%281%2C2%29%2CQ%3D%283%2C4%29)，得到![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R%3D%28-3%EF%BC%8C2%29)，我们由此验证下前面的代数表达式是否正确：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7By_P-y_Q%7D%7Bx_P-x_Q%7D%3D%5Cfrac%7B2-4%7D%7B1-3%7D%3D1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D1%5E2-1-3%3D-3%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B1+%5Ctimes%28-3-1%29%3D-2%5C%5C+%26%3Dy_Q%2Bm%28x_R-x_Q%29%3D4%2B1+%5Ctimes%28-3-3%29%3D-2+%5Cend%7Balign%7D+%5C%5C)

另外，当![[公式]](https://www.zhihu.com/equation?tex=P)或者![[公式]](https://www.zhihu.com/equation?tex=Q)其中之一是切点的时候，上述方程依然正确，具体读者可以自行验证。

而当![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)时，情况会稍微复杂一些：因为![[公式]](https://www.zhihu.com/equation?tex=x_P%3Dx_Q)，所以关于斜率我们需要采用另外一个不同的方程：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D+%5C%5C)

不难发现，正如我们期望的那样，上述![[公式]](https://www.zhihu.com/equation?tex=m)的表达式就是下式的一阶导数：

![[公式]](https://www.zhihu.com/equation?tex=y_P%3D%5Cpm+%5Csqrt%7Bx%5E3_P%2Bax_P%2Bb%7D+%5C%5C)

为了证明这一结果的有效性，只需检查![[公式]](https://www.zhihu.com/equation?tex=R)在这条椭圆曲线上，以及经过![[公式]](https://www.zhihu.com/equation?tex=R)和 ![[公式]](https://www.zhihu.com/equation?tex=P)的直线与椭圆曲线只有两个交点。当然，具体证明还是交给相关专业的数学教材，这里只举一个具体的例子：![[公式]](https://www.zhihu.com/equation?tex=P%3DQ%3D%281%EF%BC%8C2%29)。

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+m%26%3D%5Cfrac%7B3x%5E2_P%2Ba%7D%7B2y_P%7D%3D%5Cfrac%7B3%5Ctimes+1%5E2-7%7D%7B2%5Ctimes+2%7D%3D-1%5C%5C+x_R%26%3Dm%5E2-x_P-x_Q%3D%28-1%29%5E2-1-1%3D-1%5C%5C+y_R%26%3Dy_P%2Bm%28x_R-x_P%29%3D2%2B%28-1%29+%5Ctimes%28-1-1%29%3D4+%5Cend%7Balign%7D+%5C%5C)

这里我们有![[公式]](https://www.zhihu.com/equation?tex=P%2BP%3D-R%3D%28-1%2C-4%29)，结果正确。

#### 标量乘法（Scalar multiplication）

除了加法，我们可以定义另外一个操作：标量乘法，具体如下：

![[公式]](https://www.zhihu.com/equation?tex=nP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D+%5C%5C)

其中![[公式]](https://www.zhihu.com/equation?tex=n)是一个自然数。这里我们依然可以借助前面提到的**[图形化工具](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-add.html)**对标量乘法进行演示。

从上面的形式可以看出，计算标量乘法![[公式]](https://www.zhihu.com/equation?tex=nP)需要进行![[公式]](https://www.zhihu.com/equation?tex=n)次的加法。如果![[公式]](https://www.zhihu.com/equation?tex=n)有 ![[公式]](https://www.zhihu.com/equation?tex=k)个二进制位的话，那么我们的算法复杂度将是![[公式]](https://www.zhihu.com/equation?tex=O%282%5Ek%29)，不过，对于乘法的计算有现成的更为优化的多项式级别复杂度的算法。

其中一个比较著名的是**加倍累加（double and add ）**算法。我们用一个具体的例子来解释其原理。不妨取![[公式]](https://www.zhihu.com/equation?tex=n%3D151)，其二进制表示形式为：![[公式]](https://www.zhihu.com/equation?tex=%7B10010111%7D_2)。而将二进制转化为十进制的过程可以用2的不同次方的累加表示如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+151%26%3D1%5Ctimes+2%5E7+%2B+0+%5Ctimes+2%5E6+%2B+0+%5Ctimes+2%5E5+%2B+1+%5Ctimes+2%5E4+%2B+0+%5Ctimes+2%5E3+%2B+1+%5Ctimes+2%5E2+%2B+1%5Ctimes+2%5E1+%2B+1%5Ctimes+2%5E0%5C%5C+%26%3D2%5E7%2B2%5E4%2B2%5E2%2B2%5E1%2B2%5E0+%5Cend%7Balign%7D+%5C%5C)

从这个角度，我们可以改写上述变量乘法公式：

![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P%3D2%5E7%5Ctimes+P%2B2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P+%2B+2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P+%5C%5C)

这样，标量乘法可以表示为多项式乘法类似的算法，具体步骤如下：

- 得到![[公式]](https://www.zhihu.com/equation?tex=P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=P)，得到![[公式]](https://www.zhihu.com/equation?tex=2P)
- 将![[公式]](https://www.zhihu.com/equation?tex=2P)加到![[公式]](https://www.zhihu.com/equation?tex=P)（得到![[公式]](https://www.zhihu.com/equation?tex=2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)的结果）
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E2%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)
- 不对![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)进行任何操作
- 翻倍![[公式]](https://www.zhihu.com/equation?tex=2%5E3%5Ctimes+P)，得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)
- 将翻倍的![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P)加到上一次的结果当中得到![[公式]](https://www.zhihu.com/equation?tex=2%5E4%5Ctimes+P%2B2%5E2%5Ctimes+P%2B2%5E1%5Ctimes+P%2B2%5E0%5Ctimes+P)
- ...

最后，我们仅需要7次的翻倍计算和4次的加法计算就可以得到![[公式]](https://www.zhihu.com/equation?tex=151%5Ctimes+P)的结果。

这里我们分析下这个算法的时间复杂度。如果翻倍和加法都是![[公式]](https://www.zhihu.com/equation?tex=O%281%29)的话，那么这个算法就是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)，比起之前的![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)，算法时间复杂度大大简化。

#### 对数问题（logarithm problem）

给定![[公式]](https://www.zhihu.com/equation?tex=n)和 ![[公式]](https://www.zhihu.com/equation?tex=P)，我们有一个至少是多项式时间复杂度的算法来计算![[公式]](https://www.zhihu.com/equation?tex=Q%3DnP)。但是，如果反过来呢？比如已知![[公式]](https://www.zhihu.com/equation?tex=Q)和 ![[公式]](https://www.zhihu.com/equation?tex=P)来计算![[公式]](https://www.zhihu.com/equation?tex=n)呢？通常将这种问题叫作对数问题（logarithm problem）。之所以用对数来代替除法是为了与其它的加密系统保持一致。

对于对数问题我们不知道是否有可以称之为“简单”的算法，但是通过**[一些乘法实验](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/reals-mul.html%3Fa%3D-3%26b%3D1%26px%3D0%26py%3D1)**还是很容易看出一些规律的。比如，以椭圆曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-3x%2B1)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%280%2C1%29)为例。我们可以立刻确认，如果![[公式]](https://www.zhihu.com/equation?tex=n)是奇数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的左半部分；如果![[公式]](https://www.zhihu.com/equation?tex=n)是偶数，![[公式]](https://www.zhihu.com/equation?tex=nP)将会在曲线的右半部分。如果我们做更多的实验，我们可以发现更多的规律，最终可以指引我们写出一个基于特定曲线的求解对数问题的特定算法。

当然，对数问题也有一些衍生：离散对数问题。这个将在下一篇文章当中进行讨论，如果我们减小椭圆曲线的域，变量乘法依然“简单”，但是离散对数却变成一个“难题”，这个双重特性是椭圆曲线密码学的基石。

### 有限域的椭圆曲线及离散对数问题

* 本文承接上文所讨论的椭圆曲线，并将曲线的定义域从实数域缩小到了有限域，引出离散对数问题
* 首先介绍了有限域的定义，并给出了一种基于模运算的有限域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)
* 然后对离散域上的椭圆曲线重新进行群的构建
* 接着介绍了群的阶数的概念，介绍了计算椭圆曲线上的群的阶数的算法，并讨论群和子群的阶数的联系
* 随后展示了如何用椭圆曲线上的任意一点，通过计算点的倍数的方法，构造一个循环子群
* 最后介绍了一种算法，可以在椭圆曲线上找到一个基点，并通过该基点生成一个阶数为大质数的循环子群

#### 模![[公式]](https://www.zhihu.com/equation?tex=P)的整数域

有限域，顾名思义，就是一个包含有限个元素的集合。一个有限域的具体例子就是模![[公式]](https://www.zhihu.com/equation?tex=p)的整数域，其中![[公式]](https://www.zhihu.com/equation?tex=p)是一个素数。通常它可表示为![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BZ%7D%2Fp%2CGF%28p%29%2C%5Cmathbb%7BF%7D_p)等，为了简洁，本文采用最后一种符号![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)。

在有限域中，我们有两种二元操作：加法![[公式]](https://www.zhihu.com/equation?tex=%28%2B%29)和乘法![[公式]](https://www.zhihu.com/equation?tex=%28%5Ctimes%29)。两者都满足封闭性、结合律和交换律。对这两个操作，存在独一无二的单位元，且对每一个元素都有一个唯一的逆元。

最后，乘法相对加法满足分配率：![[公式]](https://www.zhihu.com/equation?tex=x%5Ctimes+%28y%2Bz%29%3Dx%5Ctimes+y%2Bx%5Ctimes+z)

模![[公式]](https://www.zhihu.com/equation?tex=p)的整数域是包含所有从0到![[公式]](https://www.zhihu.com/equation?tex=p-1)的整数，即集合![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)是定义在整数集![[公式]](https://www.zhihu.com/equation?tex=%5C%7B0%2C1%2C2%2C...%2Cp-1%5C%7D)上。在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)上面的加法和乘法以**[模运算（modular arithmetic）](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Modular_arithmetic)**的方式进行工作。下面是一些在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_%7B23%7D)上面的操作实例：

- 加法：![[公式]](https://www.zhihu.com/equation?tex=%2818%2B9%29+%5Cmod+23%3D4)
- 减法：![[公式]](https://www.zhihu.com/equation?tex=%287-14%29+%5Cmod+23+%3D16)
- 乘法：![[公式]](https://www.zhihu.com/equation?tex=4%5Ctimes+7+%5Cmod+23%3D5)
- 加法逆元：![[公式]](https://www.zhihu.com/equation?tex=-5+%5Cmod+23%3D18) 实际上：作为加法群时，其单位元为0，根据![[公式]](https://www.zhihu.com/equation?tex=%285%2B%28-5%29%29+%5Cmod+23+%3D+%285%2B18%29%5Cmod+23%3D0)，有![[公式]](https://www.zhihu.com/equation?tex=-5+%5Cmod+23%3D18)
- 乘法逆元：![[公式]](https://www.zhihu.com/equation?tex=9%5E%7B-1%7D%5Cmod+23%3D18) 实际上：作为乘法群时，其单位元为1，根据![[公式]](https://www.zhihu.com/equation?tex=9%5Ctimes+9%5E%7B-1%7D+%5Cmod+23+%3D+9%5Ctimes+18%5Cmod+%3D+1)，有![[公式]](https://www.zhihu.com/equation?tex=9%5E%7B-1%7D%5Cmod+23%3D18)

正如我们之前所说，整数对![[公式]](https://www.zhihu.com/equation?tex=p)取模后所组成的有限域将具备以上所有性质。不过需要注意的是，![[公式]](https://www.zhihu.com/equation?tex=p)必须是一个质数！否则将无法成为一个域。比如模4整数集就不是一个域：因为2没有乘法逆元，即方程![[公式]](https://www.zhihu.com/equation?tex=2%5Ctimes+x+%5Cmod+4+%3D+1)无解。

#### 模![[公式]](https://www.zhihu.com/equation?tex=p)除法

在完成对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上面对椭圆曲线进行定义之前，我们先来搞搞清楚![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上面![[公式]](https://www.zhihu.com/equation?tex=x%2Fy)意味着什么。本质上，我们可以认为：![[公式]](https://www.zhihu.com/equation?tex=x%2Fy%3Dx%5Ctimes+y%5E%7B-1%7D)，用语言来表示就是![[公式]](https://www.zhihu.com/equation?tex=x) 除以![[公式]](https://www.zhihu.com/equation?tex=y)等价于![[公式]](https://www.zhihu.com/equation?tex=x)乘以![[公式]](https://www.zhihu.com/equation?tex=y)的乘法逆元。这个结果并不意外，且给出了求解除法的基本方法：找到元素的乘法逆元然后再做一个乘法。

利用**[扩展欧几里德算法（Extended Euclidean algorithm）](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Extended_Euclidean_algorithm)**可以“方便”地计算乘法逆元，即便在最坏的情况下，算法的时间复杂度也仅为![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+p%29)，如果考虑![[公式]](https://www.zhihu.com/equation?tex=p)的二进制比特长度为![[公式]](https://www.zhihu.com/equation?tex=k)的话，则为![[公式]](https://www.zhihu.com/equation?tex=O%28k%29)。

现在，我们有足够的必要条件对![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线进行定义，前面实数域上的定义如下：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%5Cmathbb%7BR%7D%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb%2C4a%5E3%2B27b%5E2%5Cneq0%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)有限域上的定义如下：

![[公式]](https://www.zhihu.com/equation?tex=E%3D%5C%7B%28x%2Cy%29+%5Cin+%28%5Cmathbb%7BF%7D_p%29%5E2+%7C+y%5E2%3Dx%5E3%2Bax%2Bb+%5Cpmod%7Bp%7D%2C4a%5E3%2B27b%5E2%5Cnot%5Cequiv0%5Cpmod%7Bp%7D%5C%7D%5Ccup%5C%7B0%5C%7D+%5C%5C)

其中0依然是位于无限远的点，![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的两个整数。

![img](https://pic4.zhimg.com/80/v2-dfd9efe44dca23b82a045f839960df1b_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-cdbe8abec7b33dc62d0a96fc34aa019d_720w.jpg)

从几何的角度，图形则从连续的曲线变成![[公式]](https://www.zhihu.com/equation?tex=xy)平面上面的不相连的离散点的集合。好在，我们可以依然证明，即便我们对于定义域进行诸多限制，![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线依然可以组成一个阿贝尔群。

#### 点加法

显然，为了使得点加法在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上依然有效，我们需要对定义作一些小小的修改。对于实数，我们定义三个共线的点之和为0。这个定义可以保留，但是我们需要搞明白在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域中三点共线意味着什么。

在实数域，显然，三点共线意味着能够找到一条直线将三个点连在一起就好。当然，在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域中，直线与实数域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BR%7D)中的是有所不同的。不太严谨地说，![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)中的直线是满足方程![[公式]](https://www.zhihu.com/equation?tex=ax%2Bby%2Bc%5Cequiv+0%5Cpmod%7Bp%7D)的点![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%29)的集合。

![img](https://pic3.zhimg.com/80/v2-2a8d96820cefdc9053bd1ef083b720da_720w.jpg)

假设我们在一个群当中，点加法将保留所有我们已知的特性：

- ![[公式]](https://www.zhihu.com/equation?tex=Q%2B0%3D0%2BQ%3DQ)
- 对于一个非0的点![[公式]](https://www.zhihu.com/equation?tex=Q)，逆元![[公式]](https://www.zhihu.com/equation?tex=-Q)是横坐标相同但是纵坐标相反的点。或者如果你愿意，可以这样计算，![[公式]](https://www.zhihu.com/equation?tex=-Q%3D%28x_Q%2C-y_Q+%5Cmod+p%29)，举个例子，在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_29)域上的曲线有一个点![[公式]](https://www.zhihu.com/equation?tex=Q%3D%282%2C5%29)，则其逆元![[公式]](https://www.zhihu.com/equation?tex=-Q%3D%282%2C-5+%5Cmod+29%29%3D%282%2C24%29)
- 根据逆元的定义有![[公式]](https://www.zhihu.com/equation?tex=P%2B%28-P%29%3D0)

除了在每一个表达式后面加上一个![[公式]](https://www.zhihu.com/equation?tex=%5Cmod+p)的操作以外其它与前一篇文章当中所描述的步骤都相同。因此，令![[公式]](https://www.zhihu.com/equation?tex=P%3D%28x_P%2Cy_p%29%2CQ%3D%28x_Q%2Cy_Q%29%2CR%3D%28x_R%2Cy_R%29)，我们可以按如下方程计算![[公式]](https://www.zhihu.com/equation?tex=P%2BQ%3D-R)：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+x_R%26%3D%28m%5E2-x_P-x_Q%29%5Cmod%5C%2C+p%5C%5C+y_R%26%3D%5By_P%2Bm%28x_R-x_P%29%5D%5Cmod%5C%2C+p%5C%5C+%26%3D%5By_Q%2Bm%28x_R-x_Q%29%5D%5Cmod%5C%2C+p+%5Cend%7Balign%7D+%5C%5C)

如果![[公式]](https://www.zhihu.com/equation?tex=P%5Cneq+Q)，斜率![[公式]](https://www.zhihu.com/equation?tex=m)的形式如下：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%28y_P-y_Q%29%7B%28x_P-x_Q%29%7D%5E%7B-1%7D%5Cmod%5C%2Cp+%5C%5C)

如果![[公式]](https://www.zhihu.com/equation?tex=P%3DQ)，则有：

![[公式]](https://www.zhihu.com/equation?tex=m%3D%283x%5E2_P%2Ba%29%282y_P%29%5E%7B-1%7D%5Cmod%5C%2Cp+%5C%5C)

方程形式的一致并不是巧合：实际上在任何一个域，方程的形式都是相同的，有限的或者无限的，仅在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_2)和 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_3)两个特定域上不成立。关于数学上的证明有兴趣的话可以参阅**[proof from Stefan Friedl](https://link.zhihu.com/?target=http%3A//math.rice.edu/~friedl/papers/AAELLIPTIC.PDF)**

另外，考虑到离散化后的曲线切线已无从谈起，以及其它方面的一些问题，在离散化域中，我们不再定义几何加法。

#### 椭圆曲线群的阶

显而易见，有限域上定义的椭圆曲线只有有限个点。但是有一个重要的问题不应该忽略：对于一个特定有限域上的椭圆曲线，到底有多少个点呢？

首先，我们将群中所包含点的数目定义为**群的阶**。

通常从![[公式]](https://www.zhihu.com/equation?tex=x)到 ![[公式]](https://www.zhihu.com/equation?tex=p-1)进行暴力枚举不是一个可行的方式，这个需要![[公式]](https://www.zhihu.com/equation?tex=O%28p%29)的步骤，如果![[公式]](https://www.zhihu.com/equation?tex=p)是一个很大的质数，这将是一个难题。

所幸，有一个更快的算法可以计算群的阶：**[Schoof's algorithm](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Schoof%27s_algorithm)**，这个算法可以在多项式级别的算法世界复杂度内，这正是我们所需要的。

#### 标量乘法与循环子群

![[公式]](https://www.zhihu.com/equation?tex=nP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D+%5C%5C)

这次我们依然可以使用**[翻倍累加算法](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/%23double-and-add)**将乘法计算的时间复杂度控制在![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)。

在![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_p)域上的椭圆曲线进行乘法有一个有趣的性质。以曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%5Cequiv+x%5E3%2B2x%2B3%28%5Cmod%5C%2C97%29)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%283%2C6%29)为例，**[计算](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/ecc/interactive/modk-mul.html)**![[公式]](https://www.zhihu.com/equation?tex=P)的所有乘积：

![img](https://pic1.zhimg.com/80/v2-abb286db1834b321327a4f14ea2ac2f4_720w.jpg)

- ![[公式]](https://www.zhihu.com/equation?tex=0P%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=1P%3D%283%2C6%29)
- ![[公式]](https://www.zhihu.com/equation?tex=2P%3D%2880%2C10%29)
- ![[公式]](https://www.zhihu.com/equation?tex=3P%3D%2880%2C87%29)
- ![[公式]](https://www.zhihu.com/equation?tex=4P%3D%283%2C91%29)
- ![[公式]](https://www.zhihu.com/equation?tex=5P%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=6P%3D%283%2C6%29)
- ![[公式]](https://www.zhihu.com/equation?tex=7P%3D%2880%2C10%29)
- ![[公式]](https://www.zhihu.com/equation?tex=8P%3D%2880%2C87%29)
- ![[公式]](https://www.zhihu.com/equation?tex=9P%3D%283%2C91%29)
- ...

在此，我们可以确认两件事情：第一，![[公式]](https://www.zhihu.com/equation?tex=P)的乘积只有五种可能答案：椭圆曲线上面的其它的点决不会出现；第二，这五个点循环出现。我们可以这样写：

- ![[公式]](https://www.zhihu.com/equation?tex=5kP%3D0)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B1%29P%3DP)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B2%29P%3D2P)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B3%29P%3D3P)
- ![[公式]](https://www.zhihu.com/equation?tex=%285k%2B4%29P%3D4P)

对于每一个整数![[公式]](https://www.zhihu.com/equation?tex=k)，上述5个方程可以借助模运算符压缩成一个方程：![[公式]](https://www.zhihu.com/equation?tex=kP%3D%28k%5Cmod%5C%2C5%29P)

不仅如此，我们可以立刻确认这五个点在加法操作上面也是封闭的。这意味着：不管我是加![[公式]](https://www.zhihu.com/equation?tex=0%2CP%2C2P%2C3P%2C4P)中的哪一个，结果都是上述五个点之一，其它的点依然不会出现在结果当中。

不仅仅对于![[公式]](https://www.zhihu.com/equation?tex=P%3D%283%2C6%29)，对于任何点都有这样的结果。如果我们假设一个通用的点![[公式]](https://www.zhihu.com/equation?tex=P)：

![[公式]](https://www.zhihu.com/equation?tex=nP%2BmP%3D%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D%2B%5Cunderbrace%7BP%2BP%2B...%2BP%7D_%7Bn%5C%2Ctimes%7D%3D%28n%2Bm%29P+%5C%5C)

这意味着：如果我们将两个![[公式]](https://www.zhihu.com/equation?tex=P)的乘积相加，我们将得到一个![[公式]](https://www.zhihu.com/equation?tex=P)的乘积，![[公式]](https://www.zhihu.com/equation?tex=P)的乘积在加法操作下是封闭的。

这足以证明![[公式]](https://www.zhihu.com/equation?tex=P)的乘积的集合是一个由椭圆曲线所组成的群的循环子群（cyclic subgroup）。

一个“子群”是指另外一个群的子集的群。而“循环子群”则是指子群中的元素循环地出现，就好像在前面的例子当中所示。点![[公式]](https://www.zhihu.com/equation?tex=P)被称为*发生器（generator）或者基点（base point）*。

循环子群是椭圆曲线密码学以及其它加密系统的基础。

#### 子群的阶

我们可以自问一下：由一个点![[公式]](https://www.zhihu.com/equation?tex=P)产生的子群的阶（order）是多少，或者也可以称之为![[公式]](https://www.zhihu.com/equation?tex=P)的阶。回答这个问题无法使用`Schoof's algorithm`，因为该算法只有在整个椭圆曲线上面是有效的，在子群当中就无效了。在解决这个问题之前，我们需要了解以下几点：

- 我们已经对群的阶进行过定义：阶是一个群的点数。目前这个定义依然有效，但是在一个循环子群当中，我们可以给一个新的等价的定义：循环子群的阶是使得![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的最小正整数![[公式]](https://www.zhihu.com/equation?tex=n)。我们可以看之前那个例子，我们的子群有5个点，然后我们有![[公式]](https://www.zhihu.com/equation?tex=5P%3D0)
- **[Lagrange's theorem](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory))**，![[公式]](https://www.zhihu.com/equation?tex=P)的阶与椭圆曲线本身的阶有联系，一个子群的阶是父群阶的一个因子。换句话说，如果一个椭圆曲线有![[公式]](https://www.zhihu.com/equation?tex=N)个点，然后它的一个子群有![[公式]](https://www.zhihu.com/equation?tex=n)个点，那么![[公式]](https://www.zhihu.com/equation?tex=n)是 ![[公式]](https://www.zhihu.com/equation?tex=N)的一个因子

以上两个有用的信息合在一起可以帮助我们找到基于特定几点![[公式]](https://www.zhihu.com/equation?tex=P)的子群的阶：

- 使用`Schoof's algorithm`找到椭圆曲线而阶![[公式]](https://www.zhihu.com/equation?tex=N)
- 找到![[公式]](https://www.zhihu.com/equation?tex=N)的所有因子
- 对![[公式]](https://www.zhihu.com/equation?tex=N)的每一个因子![[公式]](https://www.zhihu.com/equation?tex=n)，都计算![[公式]](https://www.zhihu.com/equation?tex=nP)
- 满足![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的最小正整数![[公式]](https://www.zhihu.com/equation?tex=n)，就是子群的阶

举个例子，曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-x%2B3)在域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_37)(F/37，显示问题)上的阶为![[公式]](https://www.zhihu.com/equation?tex=N%3D42)，则其子群可能的阶为![[公式]](https://www.zhihu.com/equation?tex=n%3D1%2C2%2C3%2C6%2C7%2C14%2C21%2C42)。如果我们选取基点![[公式]](https://www.zhihu.com/equation?tex=P%3D%282%2C3%29)，我们可以发现![[公式]](https://www.zhihu.com/equation?tex=P%5Cneq+0%2C2P%5Cneq+0%2C...%2C7P%3D0)，因此基点![[公式]](https://www.zhihu.com/equation?tex=P)的阶为![[公式]](https://www.zhihu.com/equation?tex=n%3D7)。

需要特别注意的是，选取最小的因子非常重要，而不是随机选取。如果随机选取，我们还可能选择![[公式]](https://www.zhihu.com/equation?tex=n%3D14)，虽然![[公式]](https://www.zhihu.com/equation?tex=n%3D14)是满足![[公式]](https://www.zhihu.com/equation?tex=nP%3D0)的，但是它并不是子群的阶，而且其中的一个乘数。

再举一个例子，曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%3Dx%5E3-x%2B3)在域![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbb%7BF%7D_29)上的阶为![[公式]](https://www.zhihu.com/equation?tex=N%3D37)，是一个素数，其子群可能的阶仅为![[公式]](https://www.zhihu.com/equation?tex=n%3D1%2C37)。不难猜到，当![[公式]](https://www.zhihu.com/equation?tex=n%3D1)时，子群只包含一个在无限远的点；当![[公式]](https://www.zhihu.com/equation?tex=n%3DN%3D37)时，子群包含椭圆曲线上面所有的点。

#### 寻找一个基点

对于我们的椭圆曲线加密算法，我们需要一个尽量高阶的子群。通常来说，我们选择一条椭圆曲线，计算它的阶（![[公式]](https://www.zhihu.com/equation?tex=N)），确定一个比较大的因子作为子群的阶（![[公式]](https://www.zhihu.com/equation?tex=n)），然后据此寻找一个合适的基点。下面来看看我们是如何先确定子群的阶再匹配合适的基点，而不是先找基点再计算子群的阶的。

首先，需要再介绍一个概念。**[Lagrange's theorem](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory))**表明![[公式]](https://www.zhihu.com/equation?tex=h%3DN%2Fn)一定是一个整数。![[公式]](https://www.zhihu.com/equation?tex=h)被称为子群的协因子（cofactor）。

对于椭圆曲线上面的每一个点，我们有![[公式]](https://www.zhihu.com/equation?tex=NP%3D0)，根据协因子的定义，我们有![[公式]](https://www.zhihu.com/equation?tex=n%28hP%29%3D0)。

现在假设![[公式]](https://www.zhihu.com/equation?tex=n)是一个素数，那么这个方程告诉我们点![[公式]](https://www.zhihu.com/equation?tex=G%3DhP)可以产出一个阶为![[公式]](https://www.zhihu.com/equation?tex=n)的子群。

综上所述，通过确定子群的阶，再据此寻找合适的基点的算法如下：

- 计算椭圆曲线的阶![[公式]](https://www.zhihu.com/equation?tex=N)
- 选择恰当的子群的阶![[公式]](https://www.zhihu.com/equation?tex=n)，为了使得这个算法能够正常工作，这个整数必须是素数，并且是![[公式]](https://www.zhihu.com/equation?tex=N)的一个因子
- 计算协因子![[公式]](https://www.zhihu.com/equation?tex=h%3DN%2Fn)
- 再曲线上面选择一个随机点![[公式]](https://www.zhihu.com/equation?tex=P)
- 计算![[公式]](https://www.zhihu.com/equation?tex=G%3DhP)
- 如果![[公式]](https://www.zhihu.com/equation?tex=G)是0，则返回第四步，否则，我们就找到了一个阶为![[公式]](https://www.zhihu.com/equation?tex=n)且协因子为![[公式]](https://www.zhihu.com/equation?tex=h)的子群

需要指出的是该算法当且仅当![[公式]](https://www.zhihu.com/equation?tex=n)是素数的时候才能够正常工作，如果![[公式]](https://www.zhihu.com/equation?tex=n)不是一个素数，则![[公式]](https://www.zhihu.com/equation?tex=G)的阶会是![[公式]](https://www.zhihu.com/equation?tex=n)的一个因子。

#### 离散对数

正如我们再之前那篇文章当中对连续的椭圆曲线所做的，对于定义在离散域当中的椭圆曲线，我们接下来讨论一下下面这个问题：如果已知![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，如果求得满足![[公式]](https://www.zhihu.com/equation?tex=Q%3DkP)的 ![[公式]](https://www.zhihu.com/equation?tex=k)呢？

这个问题，就是经典的椭圆曲线*离散对数问题*，通常来说是“hard”的问题，在经典的计算机上面是无法通过多项式级别的时间复杂度来解决这个问题的，尽管目前还没有严格的数学证明。

这个问题和其它加密系统当中使用的离散对数问题类似，比如`DSA`，`D-H`和`ElGamal`。这并不是一个巧合。不同的是，在这些算法当中，我们使用幂模运算来代替标量乘法。这些离散对数问题可以表示如下： 已知![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)，求满足![[公式]](https://www.zhihu.com/equation?tex=b%3Da%5Ek+%5Cmod+p)

两个问题都是离散的，因为它只与有限的集合相关，更加精确地说，是循环子群。而当前椭圆曲线加密更为有趣是在于它比起其它类似的加密系统难题更难，可以使用更小的字节来表示整数![[公式]](https://www.zhihu.com/equation?tex=k)来获得的安全级别。

### ECDH加密算法和ECDSA数字签名算法

* 本文承接上文所引出的离散对数问题，在加密和数字签名两个场景就离散对数问题的具体应用方式展开具体的讨论。首先介绍了用于定义一个特定椭圆曲线离散域的子群的领域参数，然后基于这组领域参数分别在加密领域介绍`ECDH`算法，在数字签名领域介绍`ECDSA`算法。

#### 领域参数

我们的椭圆曲线算法是在一个定义在一个椭圆曲线离散有限域的循环子群上面的，因此，我们的算法需要以下参数：

- 标识有限域规模的素数![[公式]](https://www.zhihu.com/equation?tex=p)
- 椭圆曲线方程的系数![[公式]](https://www.zhihu.com/equation?tex=a)和 ![[公式]](https://www.zhihu.com/equation?tex=b)
- 产生子群的基准点![[公式]](https://www.zhihu.com/equation?tex=G)
- 子群的阶![[公式]](https://www.zhihu.com/equation?tex=n)
- 子群的协因子![[公式]](https://www.zhihu.com/equation?tex=h)

一言以蔽之，我们算法的领域参数就是一个包含六个元素的元组![[公式]](https://www.zhihu.com/equation?tex=%28p%2Ca%2Cb%2CG%2Cn%2Ch%29)

#### 随机曲线 

当我们在说离散对数问题是“hard”的时候，其实也并不完全对。有些特定的椭圆曲线所对应的离散对数问题可以用特殊目的的算法进行高效地破解。举个例子，所有满足![[公式]](https://www.zhihu.com/equation?tex=p%3Dhn)的曲线（有限域的阶与椭圆曲线的阶相同）在**[Smart's attack](https://link.zhihu.com/?target=https%3A//wstein.org/edu/2010/414/projects/novotney.pdf)**面前是脆弱的，该算法可以用经典计算机在多项式时间复杂度内解决离散对数问题。

现在，假设我给你一条椭圆曲线的领域参数。那么存在这样一个可能性，我已经发现了一些你并不知道的难度较低的椭圆曲线，并且还可能构思了一些破解我所给定的曲线的算法。我要如何向你证明我并不知道这条曲线的任何弱点呢？换句话说，我如何向你确保我所给你的这条曲线是安全的呢？

为了解决这类问题，有时候我们需要一个额外的领域参数：种子参数。这是一个用于产生方程系数和/或基准点的随机数。这些参数通过计算种子的哈希获得。众所周知，哈希的计算是“easy”的，但是求逆是“hard”的。

![img](https://pic2.zhimg.com/80/v2-385e62992a87e47388fa692ddef740c5_720w.png)

从一个种子产出一个随机曲线示意图：随机数被用于计算曲线的不同参数

![img](https://pic2.zhimg.com/80/v2-aeb7dc1eb34d94bd4a2d6145477f8f99_720w.jpg)

如果我们想从领域参数反方向构建一个种子，需要解决哈希求逆的难题

通过种子产生的曲线可以被认为是随机的。这种通过哈希来产生参数的原则被称为**[nothing up my sleeve](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Nothing-up-my-sleeve_number)**，通过哈希计算产生的数可以在根本上排除其具有掩藏特性的嫌疑，在密码学当中被大量的使用。

从某种程度上说，这个技巧可以确保给定的曲线没有被特殊的认为加工以向其作者暴露其脆弱性。事实上，如果我同时给你一条曲线和一个种子，这意味着我并不能随意选择参数，你也能够相对比较明确其实我并不能对该曲线进行特殊目的的攻击。

用于产生和验证随机曲线的标准算法在`ANSI X9.62`当中有进行描述，主要基于**[SHA-1](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/SHA-1)**，如果你对此比较好奇，你可以阅读这篇文档：**[a specification by SECG](https://link.zhihu.com/?target=http%3A//www.secg.org/sec1-v2.pdf)**，了解产生可验证的随机曲线的算法。

原作者写了一段简单的**[Python 脚本](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/scripts/verifyrandom.py)**来验证当前所有基于**[OpenSSL](https://link.zhihu.com/?target=https%3A//github.com/openssl/openssl/blob/81fc390/crypto/ec/ec_curve.c)**的随机曲线，强烈推荐看一下。

#### 椭圆曲线密码学

前面经过了很多的铺垫，不过最终我们来到了这里，可以讲下椭圆曲线密码学到底是什么了，简洁的版本如下：

- 私钥（private key）是从![[公式]](https://www.zhihu.com/equation?tex=%5C%7B1%2C...%2Cn-1%5C%7D)随机选取的一个正整数![[公式]](https://www.zhihu.com/equation?tex=d)，其中![[公式]](https://www.zhihu.com/equation?tex=n)是子群的阶
- 公钥（public key）则是点![[公式]](https://www.zhihu.com/equation?tex=H%3DdG)，其中![[公式]](https://www.zhihu.com/equation?tex=G)是子群的基准点

你看，如果我们知道![[公式]](https://www.zhihu.com/equation?tex=d)和 ![[公式]](https://www.zhihu.com/equation?tex=G)，结合其它的领域参数，求解![[公式]](https://www.zhihu.com/equation?tex=H)是“easy”的。但是，如果我们知道![[公式]](https://www.zhihu.com/equation?tex=H)和 ![[公式]](https://www.zhihu.com/equation?tex=G)，求解私钥![[公式]](https://www.zhihu.com/equation?tex=d)是“hard”的，因为这需要我们解决离散对数问题。

接下来我们介绍两个基于椭圆曲线密码学的公钥算法：

- ECDH（Elliptic Curve Diffie-Hellman）：主要用于加密
- ECDSA（Elliptic Curve Digital Signature Algorithm）：主要用于数字签名

#### ECDH加密算法

`ECDH`是**[Diffie-Hellman algorithm](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)**基于椭圆曲线的变种，更像是一个**[key-agreement protocol](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Key-agreement_protocol)**，而不是一个加密算法。因为，`ECDH`仅仅定义了各种密钥如何产生以及在各方之间如何交换，具体如何用这些密钥来对数据进行加密由用户自己决定。

这个问题是如下解决的：双方（还是喜闻乐见的**[Alice and Bob](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Alice_and_Bob)**）想安全的交换信息，**[第三方](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Man-in-the-middle_attack)**可能截取信息，但可能无法进行解码。这是传输层安全（TLS）设计的原则之一，下面来一起看一个例子。

具体工作原理如下：

- 第一步，Alice和Bob产生各自的私钥和公钥，Alice的私钥和公钥分别为![[公式]](https://www.zhihu.com/equation?tex=d_A)和 ![[公式]](https://www.zhihu.com/equation?tex=H_A%3Dd_A+G)，Bob的私钥和公钥分别为![[公式]](https://www.zhihu.com/equation?tex=d_B)和 ![[公式]](https://www.zhihu.com/equation?tex=H_B%3Dd_B+G)。需要注意的是，Alice和Bob使用相同的领域参数：在相同的有限域内定义的相同的椭圆曲线上的相同的基准点![[公式]](https://www.zhihu.com/equation?tex=G)
- Alice和Bob通过不安全的渠道交换他们的公钥![[公式]](https://www.zhihu.com/equation?tex=H_A)和 ![[公式]](https://www.zhihu.com/equation?tex=H_B)，第三方可能截取![[公式]](https://www.zhihu.com/equation?tex=H_A)和 ![[公式]](https://www.zhihu.com/equation?tex=H_B)， 但是无法仅仅通过公钥避开离散对数难题而推导出私钥![[公式]](https://www.zhihu.com/equation?tex=d_A)和 ![[公式]](https://www.zhihu.com/equation?tex=d_B)
- Alice用自己的私钥和Bob的公钥计算![[公式]](https://www.zhihu.com/equation?tex=S%3Dd_A+H_B)，然后Bob也用自己的私钥和Alice的公钥计算![[公式]](https://www.zhihu.com/equation?tex=S%3Dd_B+H_A)，事实上，对于Alice和Bob，这个![[公式]](https://www.zhihu.com/equation?tex=S)是相同的：

![[公式]](https://www.zhihu.com/equation?tex=S%3Dd_A+H_B%3Dd_A%28d_B+G%29%3Dd_B%28d_AG%29%3Dd_B+H_A+%5C%5C)

截取信息的中间人，只知道![[公式]](https://www.zhihu.com/equation?tex=H_A)和 ![[公式]](https://www.zhihu.com/equation?tex=H_B)以及其它的领域参数，但是依然无法获得在Alice和Bob之间共享的秘密信息![[公式]](https://www.zhihu.com/equation?tex=S)。这个问题就是众所周知的`Diffie-Hellman problem`，可以具体表述如下：

* 给出三个点![[公式]](https://www.zhihu.com/equation?tex=P)，![[公式]](https://www.zhihu.com/equation?tex=aP) 和![[公式]](https://www.zhihu.com/equation?tex=bP)，求![[公式]](https://www.zhihu.com/equation?tex=abP)

或者等价于：

* 给出三个整数![[公式]](https://www.zhihu.com/equation?tex=k)，![[公式]](https://www.zhihu.com/equation?tex=k%5Ex) 和![[公式]](https://www.zhihu.com/equation?tex=k%5Ey)，求![[公式]](https://www.zhihu.com/equation?tex=k%5E%7Bxy%7D)

后面这个等价基于幂模运算，在原始的`Diffie-Hellman`算法当中使用。

![img](https://pic3.zhimg.com/80/v2-a061cbc7b3360a43a9514fd9e869b8ba_720w.jpg)

Alice和Bob可以非常方便的计算出共享的机密信息，对于截取信息的第三方来说却非常难

`Diffie-Hellman problem`背后的基本原理在**[Youtube video by Khan Academy](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DYEBfamv-_do%23t%3D02m37s)**当中也有解释，一会儿也会对采用幂模运算的原始`Diffie-Hellman`算法进行介绍。

采用椭圆曲线的`Diffie-Hellman problem`被认为是“hard”的，可以等同于离散对数问题的难度级别，不过并没有数学上面的严格证明。我们能够确认的是并没有比离散对数更难，因为解决离散对数问题是解决`Diffie-Hellman problem`的一种方式。

现在，Alice和Bob已经获得了共享的机密信息，这样他们就可以用对称加密的方式进行数据交换。

举个例子，Alice和Bob可以使用![[公式]](https://www.zhihu.com/equation?tex=S)的 ![[公式]](https://www.zhihu.com/equation?tex=x)坐标作为安全加密算法**[AES](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Advanced_Encryption_Standard)**或者**[3DES](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Triple_DES)**对信息进行加密的密钥。

这个和TLS的做法类似，区别在于，TLS将坐标于其它相关的数字连接起来，然后计算连接结果字符串的哈希。

#### ECDH应用举例

**[这段代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/scripts/ecdhe.py)**可以用来计算基于特定椭圆曲线的公钥和私钥以及共享加密信息。

不同于我们之前所使用的例子，这段代码使用了一个标准的曲线，而不是一个在一个很小域上面的简单曲线。这个曲线是`secp256k1`，也是比特币里面用于数字签名的曲线。具体的领域参数如下：

- ![[公式]](https://www.zhihu.com/equation?tex=p) = 0xffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f
- ![[公式]](https://www.zhihu.com/equation?tex=a) = 0
- ![[公式]](https://www.zhihu.com/equation?tex=b) = 7
- ![[公式]](https://www.zhihu.com/equation?tex=x_G) = 0x79be667e f9dcbbac 55a06295 ce870b07 029bfcdb 2dce28d9 59f2815b 16f81798
- ![[公式]](https://www.zhihu.com/equation?tex=y_G) = 0x483ada77 26a3c465 5da4fbfc 0e1108a8 fd17b448 a6855419 9c47d08f fb10d4b8
- ![[公式]](https://www.zhihu.com/equation?tex=n) = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141
- ![[公式]](https://www.zhihu.com/equation?tex=h) = 1

这些参数来自**[OpenSSL 源码](https://link.zhihu.com/?target=https%3A//github.com/openssl/openssl/blob/81fc390/crypto/ec/ec_curve.c%23L766)**

这段代码非常简单，包含了一些我之前描述过的算法：点加法、翻倍与累加、ECDH等等。建议阅读并跑一下，代码的输出如下：

```text
Curve: secp256k1
Alice's private key: 0xc72e432030e533d59619f1ccb345015d874c5397e3fce829847b010e7f75e1a9
Alice's public key: (0x757abaa45b6938d6db9b91ca66f9ff7bac0e05ed78aa89a22a2a6a9d3bce0da4, 0x8815d45af0415f6d8d9506b15e989506968f159bf76b99a10f5200955ecba331)
Bob's private key: 0xce6f22b6d8dd621d23d0f1a6219e36619df2531d4985e47eb0c154375229e896
Bob's public key: (0x524a4c7666ec851b60a0540e24b66da2029d3baf8cb792d4e1a8f413a8a365a2, 0x39ded69ea9a5aac69fb53b736c310c267e16c3c0863576bd5aa4ebefb9b8b5db)
Shared secret: (0x68054720a6a2c983e95365c1addac5f5f5f5bd8239dce8757630247bb3368812, 0x7185800dc5f2010bb3f71f0c180d6b14f85a55302679f558d103277eaf55cd93)
```

#### Ephemeral ECDH

可能有些人除了`ECDH`，还听说过`ECDHE`。在`ECDHE`当中的“E”代表“Ephemeral”，指的是密钥的交换是暂时的。

举个`ECDHE`的应用例子，在TLS当中，服务器和用户端在每次建立起连接的时候都产生密钥对，然后用TLS证书对密钥进行签名后在双方进行交换。

#### ECDSA数字签名算法

关于数字签名算法──`ECDSA`，在**[这篇文章](https://link.zhihu.com/?target=http%3A//datacruiser.io/2019/12/12/%E7%90%86%E8%A7%A3ECDSA%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE/)**已经有了较为详细的描述，不过为了行文的完整性，这里还是再复述一遍。

我们考虑这样的一个场景：Alice想用他的私钥![[公式]](https://www.zhihu.com/equation?tex=d_A)对一个信息进行签名，然后Bob想用Alice的公钥![[公式]](https://www.zhihu.com/equation?tex=H_A)来验证这个签名。没有其它人，只有Alice才能够产生这样有效的签名。因为Alice的公钥可以公开，因此，每个人可以检查这个签名。

再一次，Alice和Bob使用相同的领域参数。接下来要看的算法是`ECDSA`，应用与椭圆曲线的**[数字签名算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Digital_Signature_Algorithm)**的变种。

`ECDSA`工作在加密信息的哈希上面，而不是信息本身。哈希函数的选择由用户自己确定，显然，为了确保安全性，还是需要采用**[密码级安全的哈希函数](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cryptographic_hash_function)**。加密信息的哈希需要进行截取以确保哈希的字节长度与子群的阶![[公式]](https://www.zhihu.com/equation?tex=n)相等，被截取的哈希是一个正整数，通常用![[公式]](https://www.zhihu.com/equation?tex=z)来表示。

Alice采用的信息签名算法工作流程如下：

- 从![[公式]](https://www.zhihu.com/equation?tex=%5C%7B1%2C...%2Cn-1%5C%7D)中随机选择一个整数![[公式]](https://www.zhihu.com/equation?tex=k)
- 计算点![[公式]](https://www.zhihu.com/equation?tex=P%3DkG)，其中![[公式]](https://www.zhihu.com/equation?tex=G)是领域参数当中的基点
- 计算数字![[公式]](https://www.zhihu.com/equation?tex=r%3Dx_P+%5Cmod+n)，其中![[公式]](https://www.zhihu.com/equation?tex=x_P)是点![[公式]](https://www.zhihu.com/equation?tex=P)的 ![[公式]](https://www.zhihu.com/equation?tex=x)坐标
- 如果![[公式]](https://www.zhihu.com/equation?tex=r%3D0)，选择另外一个![[公式]](https://www.zhihu.com/equation?tex=k)
- 计算![[公式]](https://www.zhihu.com/equation?tex=s%3Dk%5E%7B-1%7D%28z%2Br+d_A%29+%5Cmod+n)，其中![[公式]](https://www.zhihu.com/equation?tex=d_A)是Alice的私钥，![[公式]](https://www.zhihu.com/equation?tex=k%5E%7B-1%7D)是 ![[公式]](https://www.zhihu.com/equation?tex=k)模 ![[公式]](https://www.zhihu.com/equation?tex=n)的乘法逆元
- 如果![[公式]](https://www.zhihu.com/equation?tex=s%3D0)，则选择另外一个![[公式]](https://www.zhihu.com/equation?tex=k)继续

最后![[公式]](https://www.zhihu.com/equation?tex=%28r%2Cs%29)是数字签名对。

![img](https://pic3.zhimg.com/80/v2-40030afa1a2426c04ba8ce395192b606_720w.jpg)

用朴实的语言来描述，该算法首先产生机密信息![[公式]](https://www.zhihu.com/equation?tex=k)，然后将这个机密信息用椭圆曲线上面的点乘法（根据之前的知识，这个算法也是单向容易，反向难）隐藏在![[公式]](https://www.zhihu.com/equation?tex=r)当中。然后将![[公式]](https://www.zhihu.com/equation?tex=r)通过方程![[公式]](https://www.zhihu.com/equation?tex=s%3Ds%3Dk%5E%7B-1%7D%28z%2Br+d_A%29+%5Cmod+n)捆绑在加密消息哈希当中。

需要注意的是为了计算![[公式]](https://www.zhihu.com/equation?tex=s)，我们需要计算![[公式]](https://www.zhihu.com/equation?tex=k) 模![[公式]](https://www.zhihu.com/equation?tex=n)的逆元，我们已经在前面讲到只有在![[公式]](https://www.zhihu.com/equation?tex=n)是素数的时候这个算法才能够有效。如果子群有非素数的阶，那么`ECDSA`是不能使用的。几乎所有标准曲线都用一个素数阶，而那些具有非素数阶的曲线并不适合于`ECDSA`。

#### 数字签名验证

为了对数字签名进行验证，我需要Alice的公钥![[公式]](https://www.zhihu.com/equation?tex=H_A)，截取后的哈希![[公式]](https://www.zhihu.com/equation?tex=z)，当然，也需要签名对![[公式]](https://www.zhihu.com/equation?tex=%28r%2Cs%29)，主要分以下三步：

- 计算![[公式]](https://www.zhihu.com/equation?tex=u_1%3Ds%5E%7B-1%7Dz+%5Cmod+n)
- 计算![[公式]](https://www.zhihu.com/equation?tex=u_2%3Ds%5E%7B-1%7Dr+%5Cmod+n)
- 计算点![[公式]](https://www.zhihu.com/equation?tex=P%3Du_1G%2Bu_2+H_A)

如果![[公式]](https://www.zhihu.com/equation?tex=r%3Dx_P+%5Cmod+n)则签名是有效的

#### 算法的正确性

初看起来，隐藏在算法背后的逻辑并不是那么清晰，不过，当我们将目前所有列出的方程都放到一起就清楚明了了。

让我们从![[公式]](https://www.zhihu.com/equation?tex=P%3Du_1G+%2B+u_2+H_A)开始，我们知道，从公钥的定义可知，![[公式]](https://www.zhihu.com/equation?tex=H_A%3Dd_A+G)，其中![[公式]](https://www.zhihu.com/equation?tex=d_A)是私钥，我们可以将式子改写如下：

![[公式]](https://www.zhihu.com/equation?tex=P%3Du_1G+%2B+u_2+H_A%3Du_1+G+%2B+u_2+d_A+G%3D%28u_1%2Bu_2+d_A%29G+%5C%5C)

再次利用![[公式]](https://www.zhihu.com/equation?tex=u_1)和 ![[公式]](https://www.zhihu.com/equation?tex=u_2)的定义，我们可以将式子改写如下：

![[公式]](https://www.zhihu.com/equation?tex=P%3D%28u_1%2Bu_2+d_A%29G%3D%28s%5E%7B-1%7Dz%2Bs%5E%7B-1%7Drd_A%29G%3Ds%5E%7B-1%7D%28z%2Brd_A%29G+%5C%5C)

这里为了简化，我们将后续的![[公式]](https://www.zhihu.com/equation?tex=%5Cmod+n)省略，另外，因为由![[公式]](https://www.zhihu.com/equation?tex=G)产生的循环子群的阶为![[公式]](https://www.zhihu.com/equation?tex=n)，因此，![[公式]](https://www.zhihu.com/equation?tex=%5Cmod+n)是多余的。

在前面，我们定义![[公式]](https://www.zhihu.com/equation?tex=s%3Ds%3Dk%5E%7B-1%7D%28z%2Br+d_A%29+%5Cmod+n)，方程两边都乘以![[公式]](https://www.zhihu.com/equation?tex=k)在除以![[公式]](https://www.zhihu.com/equation?tex=s)，我们得到![[公式]](https://www.zhihu.com/equation?tex=k%3Ds%5E%7B-1%7D%28z%2Br+d_A%29%5Cmod+n)，将这个方程代入前面计算![[公式]](https://www.zhihu.com/equation?tex=P)的方程，我们有：

![[公式]](https://www.zhihu.com/equation?tex=P%3Ds%5E%7B-1%7D%28z%2Brd_A%29G%3DkG+%5C%5C)

这个方程与前面算法第二步当中产生签名算法计算![[公式]](https://www.zhihu.com/equation?tex=P)的方程是相同的，那意味着产生签名和验证签名的时候，我们计算同一个点![[公式]](https://www.zhihu.com/equation?tex=P)，只是采用了不同的方程，这也是算法有效的原因。

#### ECDSA应用举例

当然，原作者同样写了**[一段python代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/scripts/ecdsa.py)**用来签名的产生和验证。这段代码与`ECDH`的代码有部分相同，特别是领域参数和公/私钥对产生算法。

下面是这段代码可能的一个输出内容：

```text
urve: secp256k1
Private key: 0xdef65e81fb94235e4e52d89c2cd29718bb42c8b944700c26c4cac2f16e5f0d73
Public key: (0x42186bb04e3070de0370eff1aa4b88d6e20db8013a2daf16146119bafb211290, 0x62d3d86ee0469feab6b3fff7a295084392ef506d6836a920583520aa7e40d20b)

Message: b'Hello!'
Signature: (0x77c9fcd26adec8871bd9983c7e3aaed841e15095c2c25b4a0c46f3c4448ae7a5, 0xeb058fb78abdad4e316b44c09f1af610c389c8ae29b6f4ad19489e1c903a6807)
Verification: signature matches

Message: b'Hi there!'
Verification: invalid signature

Message: b'Hello!'
Public key: (0x7526ae6817faace403ac5dfddd6adbb3ca42a04ad58fc418d43eca4ea1c08cbd, 0x11c8b82217d09e046529ad0692859be73c3cbeca36254fa9084dccf2c8b35cc3)
Verification: invalid signature
```

你可以看到，这段代码首先对一段信息进行签名（字节信息“Hello!”），然后对签名进行验证。然后，试图用同样的签名对另外一段信息（“Hi there”）进行验证且失败了。最后，试图采用另外一个随机的公钥对同样的信息进行验证也失败了。

#### k的重要性

当我们产生`ECDSA`签名的时候，保持随机数![[公式]](https://www.zhihu.com/equation?tex=k)的机密性和随机性非常重要。如果我们在多个签名使用了同一个![[公式]](https://www.zhihu.com/equation?tex=k)，或者我们的随机数生成器某种程度上是可预测的，则很容易受到攻击而泄漏我们的私钥！

下面举一个多年前**[sony公司犯过的一个错误](https://link.zhihu.com/?target=https%3A//www.bbc.com/news/technology-12116051)**。通常，PS3平台只能运行Sony用`ECDSA`签名过的游戏。这样，如果我想为我的PS3平台创建一个新游戏，在没有Sony的签名的情况下，我无法进行私自发布。但是，问题在于所有Sony产生的签名使用了同一个随机数![[公式]](https://www.zhihu.com/equation?tex=k)。

在这种情况下，我们只要购买两个签名过的游戏，抽取出它们的哈希![[公式]](https://www.zhihu.com/equation?tex=z_1)和 ![[公式]](https://www.zhihu.com/equation?tex=z_2)以及签名对（![[公式]](https://www.zhihu.com/equation?tex=%28r_1%2Cs_1%29%2C%28r_2%2Cs_2%29)），和领域参数一起就可以破解出Sony的私钥![[公式]](https://www.zhihu.com/equation?tex=d_S)。下面是具体步骤：

- 首先，![[公式]](https://www.zhihu.com/equation?tex=r_1%3Dr_2)，因为![[公式]](https://www.zhihu.com/equation?tex=r%3Dx_P+%5Cmod+n)且 ![[公式]](https://www.zhihu.com/equation?tex=P%3DkG)对于两个签名是一样的
- 从![[公式]](https://www.zhihu.com/equation?tex=s)的定义可以推导出![[公式]](https://www.zhihu.com/equation?tex=%28s_1-s_2%29%5Cmod+n+%3D+k%5E%7B-1%7D%28z_1-z_2%29%5Cmod+n)
- 上式两旁都乘以![[公式]](https://www.zhihu.com/equation?tex=k)，有：![[公式]](https://www.zhihu.com/equation?tex=k%28s_1-s_2%29%5Cmod+n%3D%28z_1-z_2%29%5Cmod+n)
- 再两边除以![[公式]](https://www.zhihu.com/equation?tex=%28s_1-s_2%29)得到：![[公式]](https://www.zhihu.com/equation?tex=k%3D%28z_1-z_2%29%28s_1-s_2%29%5E%7B-1%7D%5Cmod+n)

最后的式子可以让我们只用两个哈希和对应的签名来计算![[公式]](https://www.zhihu.com/equation?tex=k)，得到![[公式]](https://www.zhihu.com/equation?tex=k)以后我们可以使用![[公式]](https://www.zhihu.com/equation?tex=s)的定义方程计算私钥：

![[公式]](https://www.zhihu.com/equation?tex=s%3Dk%5E%7B-1%7D%28z%2Brd_S%29%5Cmod+n+%5Crightarrow+d_S%3Dr%5E%7B-1%7D%28sk-z%29%5Cmod+n+%5C%5C)

即便![[公式]](https://www.zhihu.com/equation?tex=k)不是静态的，如果是可预测的，同样的技术也可以用于对私钥的破解。

### 破解安全性及与RSA之间的比较

在**[上一篇文章](https://link.zhihu.com/?target=http%3A//datacruiser.io/2020/02/02/Elliptic-Curve-Cryptography-ECDH-and-ECDSA/)**当中，我们了解了两种算法`ECDH`和`ECDSA`，并且也知道椭圆曲线离散对数问题是如何在安全性方面发挥重要作用的。不过，你如果留心的话，对于离散对数问题的复杂度我们还没有严格意义上的数学证明，只是主观上面认为它是“hard”，但具体是到什么程度还不知道，本文的前半部分会给你一个基于当前技术求解离散对数问题有多“hard”的一个大致认识。

第二部分，我们试着回答这个问题：在RSA等其它基于幂模运算的加密系统工作得好好的时候为什么我们还需要椭圆曲线密码系统。

#### 离散对数问题破解

接下来我们会看到两个当前最有效的椭圆曲线离散对数求解算法：`baby-step,giant-step`算法和`Pollard's rho`算法。

在开始之前，先让我们来回顾一下什么是离散对数问题：给定两个点![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，寻找整数![[公式]](https://www.zhihu.com/equation?tex=x)满足![[公式]](https://www.zhihu.com/equation?tex=Q%3DxP)，其中这些点都属于基点为![[公式]](https://www.zhihu.com/equation?tex=G)阶为![[公式]](https://www.zhihu.com/equation?tex=n)的椭圆曲线子群。

#### Baby-step giant-step

在进入具体的算法之前，我们快速过一下：对于任意一个正整数![[公式]](https://www.zhihu.com/equation?tex=x)，我们总可以将它写成这样的形式：![[公式]](https://www.zhihu.com/equation?tex=x%3Dam%2Bb)，其中![[公式]](https://www.zhihu.com/equation?tex=a%2Cm%2Cb)是任意整数。举个例子，对于10我们可以这样写10 = 2·3 + 4。

脑子里面有了这根弦以后，我们可以离散对数问题进行重写：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++Q%26%3DxP%5C%5C++Q%26%3D%28am%2Bb%29P%5C%5C+Q%26%3DamP%2BbP%5C%5C+Q-amP%26%3DbP+%5Cend%7Balign%7D+%5C%5C)

`baby-step giant-step`算法是一个在中间会合的算法。比起逐个计算每一个![[公式]](https://www.zhihu.com/equation?tex=x)来找到满足方程要求的![[公式]](https://www.zhihu.com/equation?tex=x)，对于![[公式]](https://www.zhihu.com/equation?tex=bP)我们可以计算得更少，对于![[公式]](https://www.zhihu.com/equation?tex=Q-amP)也可以计算得更少，直到我们找到一个满足条件的。算法的具体工作步骤如下：

- 计算![[公式]](https://www.zhihu.com/equation?tex=m%3D%5Clceil+%5Csqrt%7Bn%7D%5Crceil)

- 对于![[公式]](https://www.zhihu.com/equation?tex=0%2C...%2Cm)中的每一个![[公式]](https://www.zhihu.com/equation?tex=b)，计算![[公式]](https://www.zhihu.com/equation?tex=bP)并将结果保存在一张哈希表当中

- 对于![[公式]](https://www.zhihu.com/equation?tex=0%2C...%2Cm)中的每一个![[公式]](https://www.zhihu.com/equation?tex=a)：

- - 计算![[公式]](https://www.zhihu.com/equation?tex=amP)
  - 计算![[公式]](https://www.zhihu.com/equation?tex=Q-amP)
  - 检查哈希表并寻找是否存在一个点![[公式]](https://www.zhihu.com/equation?tex=bP)满足![[公式]](https://www.zhihu.com/equation?tex=Q-amP%3DbP)
  - 如果存在这样的表，那么我们就找到了这样的一个整数![[公式]](https://www.zhihu.com/equation?tex=x%3Dam%2Bb)

正如你所看到的，我们计算![[公式]](https://www.zhihu.com/equation?tex=bP)时的系数![[公式]](https://www.zhihu.com/equation?tex=b)用很小的步长，但在第二部分当中，我们计算![[公式]](https://www.zhihu.com/equation?tex=amP)使用很大的步长，这两部分分别就是算法“baby”部分和“giant”部分。具体它可以如下图所示：

![img](https://pic3.zhimg.com/v2-01b3ff936c3658c4aaad10e060fb774a_b.webp)

为了理解这个算法为何有效，先暂时不考虑点![[公式]](https://www.zhihu.com/equation?tex=bP)被缓存起来了，我们直接来看方程![[公式]](https://www.zhihu.com/equation?tex=Q%3DamP%2BbP)，看以下步骤：

- 当![[公式]](https://www.zhihu.com/equation?tex=a%3D0)时，我们检查![[公式]](https://www.zhihu.com/equation?tex=Q)是否等于![[公式]](https://www.zhihu.com/equation?tex=bP)，其中![[公式]](https://www.zhihu.com/equation?tex=b)是 ![[公式]](https://www.zhihu.com/equation?tex=0%2C...%2Cm)之间的一个整数。这样子，我们就可以将![[公式]](https://www.zhihu.com/equation?tex=Q)与所有从![[公式]](https://www.zhihu.com/equation?tex=0P)到 ![[公式]](https://www.zhihu.com/equation?tex=mP)之间的点进行比较
- 当![[公式]](https://www.zhihu.com/equation?tex=a%3D1)时，我们检查![[公式]](https://www.zhihu.com/equation?tex=Q)是否等于![[公式]](https://www.zhihu.com/equation?tex=mP%2BbP)，我们就可以将![[公式]](https://www.zhihu.com/equation?tex=Q)与所有从![[公式]](https://www.zhihu.com/equation?tex=mP)到 ![[公式]](https://www.zhihu.com/equation?tex=2mP)之间的点进行比较
- 当![[公式]](https://www.zhihu.com/equation?tex=a%3D2)时，我们可以将![[公式]](https://www.zhihu.com/equation?tex=Q)与所有从![[公式]](https://www.zhihu.com/equation?tex=2mP)到 ![[公式]](https://www.zhihu.com/equation?tex=3mP)之间的点进行比较
- ...
- 当![[公式]](https://www.zhihu.com/equation?tex=a%3Dm-1)时，我们可以将![[公式]](https://www.zhihu.com/equation?tex=Q)与所有从![[公式]](https://www.zhihu.com/equation?tex=%28m-1%29mP)到 ![[公式]](https://www.zhihu.com/equation?tex=m%5E2P%3DnP)之间的点进行比较

总结一下，我们最多在![[公式]](https://www.zhihu.com/equation?tex=2m)步的加法和乘法当中检查完所有从![[公式]](https://www.zhihu.com/equation?tex=0P)到 ![[公式]](https://www.zhihu.com/equation?tex=nP)的点，精确的说`baby steps`是![[公式]](https://www.zhihu.com/equation?tex=m)步，`giant steps`最多![[公式]](https://www.zhihu.com/equation?tex=m)步。

如果将哈希查表的时间复杂度考虑为![[公式]](https://www.zhihu.com/equation?tex=O%281%29)，不难发现整个算法的时间和空间复杂度均为![[公式]](https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29)，如果你考虑了字节的长度，则是![[公式]](https://www.zhihu.com/equation?tex=O%282%5E%7Bk%2F2%7D%29)。这依然是指数级别的时间复杂度，不过比起暴力破解还是要好不少。

#### Baby-step giant-step in practice

在实践当中我们可以看看![[公式]](https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29)到底意味着什么。我们先找一个标准曲线：`prime192v1`。这条曲线的阶为![[公式]](https://www.zhihu.com/equation?tex=n%3D)0xffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831。这个数的平方根大约为7.922816251426434·![[公式]](https://www.zhihu.com/equation?tex=10%5E%7B28%7D)

现在想象一下在一个哈希表当中存储![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D)个点，假设每个点需要32字节的空间，那么我们的哈希表需要大约2.5·![[公式]](https://www.zhihu.com/equation?tex=10%5E%7B30%7D)字节的内存空间。目前整个世界的存储能力比起这个需求都相差甚远，即便每一个点只需要1个字节的存储空间，我依然离将它们全部存下来相去甚远。

更加令人绝望的是`prime192v1`是阶数最低的曲线。另外一个来自NIST的标准曲线的阶数高达6.9·![[公式]](https://www.zhihu.com/equation?tex=10%5E%7B156%7D)，其时间和空间的复杂度更加不可想象。

#### Playing with baby-step giant-step

原作者也写了**[一段python代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/babygiantstep.py)**实现了`baby-step giant-step`算法。显然，它只能在一些阶数比较小的曲线上面工作，不要试着去采用`secp521r1`，否则会出现内存错误。

这段代码可以产出下面这样的一个输出：

> Curve: y^2 = (x^3 + 1x - 1) mod 10177 Curve order: 10331 p = (0x1, 0x1) q = (0x1a28, 0x8fb) 325 * p = q log(p, q) = 325 Took 105 steps

#### Pollard's ![[公式]](https://www.zhihu.com/equation?tex=%5Crho)  ???

`Pollard's rho`是计算离散对数问题的另外一个算法。和`baby-step giant-step`算法一样，它的时间复杂度也是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29)，但是它的空间复杂度仅仅为$O(1)。如果`baby-step giant-step`无法解决离散对数问题是因为巨大的存储空间需求，那么`Pollard's rho`是否可以呢？让我们拭目以待。

首先，再次强调一下离散对数问题的形式：给定![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，寻找![[公式]](https://www.zhihu.com/equation?tex=x)满足 ![[公式]](https://www.zhihu.com/equation?tex=Q%3DxP)。在`Pollard's rho`算法当中，我们求解一个略微不同的问题：给定![[公式]](https://www.zhihu.com/equation?tex=P)和 ![[公式]](https://www.zhihu.com/equation?tex=Q)，寻找整数![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%2CA%2CB)满足 ![[公式]](https://www.zhihu.com/equation?tex=aP%2BbQ%3DAP%2BBQ)。

当上面这四个整数找到以后，我们可以结合方程![[公式]](https://www.zhihu.com/equation?tex=Q%3DxP)解除![[公式]](https://www.zhihu.com/equation?tex=x)：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++aP%2BbQ%26%3DAP%2BBQ%5C%5C++aP%2BbxP%26%3DaP%2BBxP%5C%5C+%28a%2Bbx%29P%26%3D%28A%2BBx%29P%5C%5C+%28a-A%29P%26%3D%28B-b%29xP+%5Cend%7Balign%7D+%5C%5C)

将![[公式]](https://www.zhihu.com/equation?tex=P)消除就可以得到![[公式]](https://www.zhihu.com/equation?tex=x)。不过在这样做之前，我们必须记住我们的子群是以阶为![[公式]](https://www.zhihu.com/equation?tex=n)的循环子群，因此在点乘法当中使用的系数是要进行模![[公式]](https://www.zhihu.com/equation?tex=n)处理的，具体的![[公式]](https://www.zhihu.com/equation?tex=x)求解过程如下：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++a-A%26%5Cequiv+%28B-b%29x%28%5Cmod+n%29%5C%5C++x%26%3D%28a-A%29%28B-b%29%5E%7B-1%7D%5Cmod+n+%5Cend%7Balign%7D+%5C%5C)

`Pollard's rho`算法的操作原则非常简单：我们产生一系列的伪随机点![[公式]](https://www.zhihu.com/equation?tex=X_1%2CX_2%2C...)，其中![[公式]](https://www.zhihu.com/equation?tex=X%3Da_iP%2Bb_iQ)。这个序列可以通过一个伪随机函数![[公式]](https://www.zhihu.com/equation?tex=f)产生：

![[公式]](https://www.zhihu.com/equation?tex=%28a_%7Bi%2B1%7D%2Cb_%7Bi%2B1%7D%29%3Df%28X_i%29+%5C%5C)

伪随机函数![[公式]](https://www.zhihu.com/equation?tex=f)以最新的点![[公式]](https://www.zhihu.com/equation?tex=X_i)作为序列的输入，然后以系数![[公式]](https://www.zhihu.com/equation?tex=a_%7Bi%2B1%7D)和 ![[公式]](https://www.zhihu.com/equation?tex=b_%7Bi%2B1%7D)作为输出。由此，我们可以计算![[公式]](https://www.zhihu.com/equation?tex=X_%7Bi%2B1%7D%3Da_%7Bi%2B1%7DP%2Bb_%7Bi%2B1%7DQ)，随后，我们可以再次以![[公式]](https://www.zhihu.com/equation?tex=X_%7Bi%2B1%7D)作为输入得到新的系数，这样不断重复。

至于伪随机函数![[公式]](https://www.zhihu.com/equation?tex=f)内部是如何工作的并不重要，当然，确定的函数比起其它不确定的可以更快地获得结果。我们真正在乎的是![[公式]](https://www.zhihu.com/equation?tex=f)基于前一个点来确定下一个点，这样所有的系数![[公式]](https://www.zhihu.com/equation?tex=a_i) 和![[公式]](https://www.zhihu.com/equation?tex=b_i)对我们而言变成已知。

用这样的函数![[公式]](https://www.zhihu.com/equation?tex=f)，我们迟早会在我们的序列当中看到一个循环，从表达式上面看就是得到一个点![[公式]](https://www.zhihu.com/equation?tex=X_j%3DX_i)，如下图所示：

![img](https://pic4.zhimg.com/80/v2-516fdbdfd75927646c46d2a4d0e71a87_720w.jpg)

我们必须看到循环的原因非常简单：点的数目是有限的，因此我们迟早会重复。一旦我们看到循环在哪里开始，我们可以用这个上面的方程来求解离散对数问题。

接下来问题变成我们如何高效的检测到这个循环呢？

#### Tortoise and Hare

为了检测循环，我们有一个高效的方法：`tortoise and hare`算法，也被叫作`Floyd's cycle-finding`算法。下面的图片展示了`torise and hare`算法的操作原则，也是`Pollard's rho`算法的核心。

![img](https://pic4.zhimg.com/v2-3832db5955604c7e53afa3640ed119eb_b.webp)

我们基于曲线![[公式]](https://www.zhihu.com/equation?tex=y%5E2%5Cequiv+x%5E3%2B2x%2B3%28%5Cmod+97%29)和点![[公式]](https://www.zhihu.com/equation?tex=P%3D%283%2C6%29) 以及点![[公式]](https://www.zhihu.com/equation?tex=Q%3D%2880%2C87%29).这些点属于一个阶为5的循环子群。我们以不同的速度在一个序列对中进行工作直到找到两个不同的整数对![[公式]](https://www.zhihu.com/equation?tex=%28a%2Cb%29)和 ![[公式]](https://www.zhihu.com/equation?tex=%28A%2CB%29)产生同一个点。在这个例子当中，我们找到整数对![[公式]](https://www.zhihu.com/equation?tex=%283%2C3%29)和 ![[公式]](https://www.zhihu.com/equation?tex=%282%2C0%29)满足这个要求，然后我们可以计算该对数问题得到![[公式]](https://www.zhihu.com/equation?tex=x%3D%283-2%29%280-3%29%5E%7B-1%7D%5Cmod+5%3D3)，而事实上我们确实有![[公式]](https://www.zhihu.com/equation?tex=Q%3D3P)。

我们让tortoise和hare从序列的左边走到序列的右边，绿色的是走得慢的tortoise，一步一步地走，红色的hare每次跳过一个点得走，本质上是快慢指针法来寻找循环开始的地方。

一段时间以后，tortoise和hare会找到相同的点，但是系数对却不相同。或者用方程来表达，tortoise找到的对是![[公式]](https://www.zhihu.com/equation?tex=%28a%2Cb%29)，hare找到的对是![[公式]](https://www.zhihu.com/equation?tex=%28A%2CB%29)，且满足![[公式]](https://www.zhihu.com/equation?tex=aP%2BbQ%3DAP%2BBQ)。

非常容易看出这个算法只需要固定大小的内存空间![[公式]](https://www.zhihu.com/equation?tex=O%281%29)。但是计算时间依然开销很大，可以从概率的角度来证明时间复杂度为![[公式]](https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29)。严格的证明是基于**[birthday paradox](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Birthday_problem)**，指的是两个人生日相同的概率，这和我们所考虑的两个不同的整数对![[公式]](https://www.zhihu.com/equation?tex=%28a%2Cb%29)得到相同的点的概率类似。

> 译者注，根据文章**[最后的留言讨论](https://link.zhihu.com/?target=http%3A//blog.chxj.name/elliptic-curve-cryptography-breaking-security-and-a-comparison-with-rsa-zh/)**，实际上, 原作者关于 Pollard's ρ 算法的部分讲解是不够准确的。根据作者的前面的说法系数(a,b)总由它前面点决定, 这也就是说, 相同点一定生成相同的系数, 而 GIF 动图中的点(3,6)第一次生成了 a=3,b=3 但第二次生成了 a=2, b=0. 这与前面的说法是矛盾的，对照作者提供的python代码，下一个点的系数并非由前一个点生成, 而是由前一个点和前一个点的系数共同决定。而下一个点又能由前一个点决定, 系数和点的不同循环周期创造了找到问题的解的可能。

#### Playing with Pollard's ![[公式]](https://www.zhihu.com/equation?tex=%5Crho)

原作者有一段使用`Pollard's rho`算法的**[python代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/pollardsrho.py)**，这不是原始`Pollard's rho`算法的实现，只是一个小小的变种，作者使用了更高效的产生伪随机序列的方法。代码里面包含了一些有用的注释，如果你对算法的详细细节有兴趣，最好读一读。

和`baby-step giant-step`算法一样，也仅仅在一些小的椭圆曲线上面有效工作，并产生类似的输出。

#### Pollard's ![[公式]](https://www.zhihu.com/equation?tex=%5Crho) in practice

由于空间需求无法满足，`baby-step giant-step`在实践中是无法使用的。而`Pollard's rho`只需要很少的空间，那么他的实用性如何呢？

Certicon在1998年发起了一个在位数从109到359的椭圆曲线上面计算离散对数问题的**[挑战](https://link.zhihu.com/?target=https%3A//blackberry.certicom.com/)**，最终只有109位的曲线被成功破解，且最好的成功尝试是在2004年提交的，**[Wikipedia](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Discrete_logarithm_records)**上面的记录如下：

> The prize was awarded on 8 April 2004 to a group of about 2600 people represented by Chris Monico. They also used a version of a parallelized Pollard rho method, taking 17 months of calendar time.

正如我们之前所说，`prime192v1`是一个最小的椭圆曲线。我们也知道`Pollard's rho`的时间复杂度是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29)。如果我们使用与`Chris Monico`相同的技术（同样的算法，同样的硬件，数量相同的机器），那么在`prime192v1`上面计算离散对数问题需要化多长时间呢？

![[公式]](https://www.zhihu.com/equation?tex=17+%5C%2C%5Cmathrm%7Bmonths%7D+%5Ctimes+%5Cfrac%7B%5Csqrt%7B2%5E%7B192%7D+%7D+%7D%7B%5Csqrt%7B2%5E%7B109%7D+%7D+%7D+%5Capprox+5%5Ccdot+10%5E%7B13%7D+%5C%2C%5Cmathrm%7Bmonths%7D+%5C%5C)

这个数字可以清楚的说明使用这样的技术来破解离散对数问题是多么的困难。

#### Pollard's ![[公式]](https://www.zhihu.com/equation?tex=%5Crho) vs Baby-step giant-step

将**[baby-step giant-step代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/babygiantstep.py)**和**[Pollard's rho代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/pollardsrho.py)**和**[brute-force代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/bruteforce.py)**放到一起组成**[第四段代码](https://link.zhihu.com/?target=https%3A//github.com/andreacorbellini/ecc/blob/master/logs/comparelogs.py)**来比较他们之间的性能。

运行第四段代码可以对比所有的算法在一个阶数较小的曲线上面求解一个离散对数问题所需要的时间对比：

> Curve order: 10331 Using bruteforce Computing all logarithms: 100.00% done Took 1m 12s (5182 steps on average) Using babygiantstep Computing all logarithms: 100.00% done Took 0m 3s (152 steps on average) Using pollardsrho Computing all logarithms: 100.00% done Took 0m 8s (139 steps on average)

正如我们所期望的，暴力法（brute-force）比起另外两种算法要慢很多。`Baby-step giant-step`是最快的，`Pollard's rho`要比它慢一倍，虽然它所消耗的内存更少步数也更少。

再来看运算步数，暴力法平均需要5182步，这个数字非常接近曲线阶数的一半。`Baby-step giant-step`和`Pollard's rho`平均分别需要152和139步，两者都非常接近阶数的平方根：![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7B10331%7D%3D101.64)。

#### Final consideration

在介绍这些算法的时候，我已经给出了很多的数字。阅读的时候需要给他们足够的重视：算法可以有很多种方式来进行优化。硬件可以提升，可以构建专用硬件设备。

目前看起来不可行的方法，并不意味着后续不能提升。更不是说已经没有其它更好的方法存在。

#### Shor's algorithm

如果当前的技术不合适，那以后的呢？确实，事情的发展让人有些担忧：存在一种**[量子算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Quantum_algorithm)**可以在多项式的时间复杂度内解决离散对数问题：**[Shor's algoritm](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Shor%27s_algorithm)**的时间复杂度是![[公式]](https://www.zhihu.com/equation?tex=O%28%28%5Clog+n%29%5E3%29)，空间复杂度是![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)。

量子计算机目前还没有成熟到足以运行Shor's这样的算法，但是**[抗量子的加密算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Post-quantum_cryptography)**现在看来将会更加有研究价值，今天我们用于加密的东西在明天可能变得不再安全。

#### ECC and RSA

现在让我们忘记量子计算，把它当作一个严重问题的日子和远着呢！接下来要回答的问题是：既然`RSA`已经可以很好的工作，为什么还要大费周章地去捣鼓椭圆曲线呢？

`NIST`给出了一个简洁的答案，提供了一个取得相同等级的安全性能时两者密钥所需字节大小的对比表格：

![img](https://pic3.zhimg.com/80/v2-8329ac758fe60f5b8c673b2ba28b7c8a_720w.jpg)

需要注意的是，在`RSA`的密钥长度和`ECC`的密钥长度之间并没有线性关系，换言之，如果我们翻倍`RSA`的密钥长度，并不意味着必须对`ECC`的密钥长度进行翻倍。这个表格不仅告诉我们`ECC`使用更少的内存，而且密钥的产生和签名验证都更快。

那么这是什么原因呢？在计算离散对数问题时我们比较快的算法是前面介绍过的`Baby-step giant-step`算法和`Pollard's rho`算法，而在`RSA`的计算当中，我们有着更快、更高效的算法。特别是**[general number field sieve](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/General_number_field_sieve)**：一个整数因子分解算法可以用于计算离散对数，该算法是目前最快的因子分解算法。

所有这些都可以应用与其它基于幂模运算的加密系统，包括`DSA`，`D-H`和`EIGamal`等等。

#### Hidden threats of NSA

接下来是较难的一部分。到目前我们一直在讨论算法和数学。下面让我们把人考虑进去，这将会让问题变得更加复杂。

首先让我们放出问题，问题是：`NIST`曲线的随机数种子是哪里来的？答案是令人失望的：我们并不知道。这些种子并没有经过大家一致讨论而被认为是正当的。

是不是有这种可能，`NIST`发现了大量的弱椭圆曲线，然后尝试了大量可能的种子找到了一个有漏洞的曲线？这个问题我无法回答，但是却非常重要且关乎法律。我们知道，`NIST`确实成功标准化了至少一个**[有漏洞的随机数生成器](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dual_EC_DRBG)**。或许他们也能够标准化出一系列的含有漏洞的弱椭圆曲线。对于问题的答案，我们依然无法知晓。

尤其重要的是，需要特别理解的是“可验证的随机”和“安全”并不是等价的。不论你的离散对数问题有多难，你的密钥有多长，如果算法本身被破解了，皮之不存，毛将焉附，那么我们也是束手无策的。

基于这一点的考虑，`RSA`胜出。它并不需要特别的可能可以作弊的领域参数。在我们不信任任一权威机构以及自己无法构建我们自己的领域参数的时候，`RSA`以及其它基于幂模运算的加密系统是一个好的替代选择。如果你问：是的，传输安全层（TLS）可以使用`NIST`的曲线。如果你检查一下**[google](https://link.zhihu.com/?target=https%3A//google.com/)**，你可以看到连接就是使用了`ECDHE`和`ECDSA`，基于`prime256v1`的认证证书。

#### That's all!

最后，希望大家能够喜欢这一系列的文章。我的目的是能够给大家介绍基本的知识、术语和惯例来理解当前的`ECC`。如果能够达成我的目标，你现在可以理解现存基于`ECC`的加密系统并将你的知识延伸到阅读一些其它不那么友好的文档。当撰写这一系列的文章的时候，我本可以跳过一些详细细节，使用一个更简单的术语，但我觉得这样做你将无法理解。我相信我在简单和面面俱到之间做了很好的权衡。

务必注意，仅仅通过阅读本系列文章，你并不能实现安全的`ECC`加密系统，为了确保安全性，我们需要了解很多细微但重要的细节。记住**[Smart's attack](https://link.zhihu.com/?target=https%3A//wstein.org/edu/2010/414/projects/novotney.pdf)**和**[Sony's mistake](https://link.zhihu.com/?target=https%3A//www.bbc.com/news/technology-12116051)**──这两个例子应该可以让你知道产生不安全的算法是多么的容易，不安全的算法被人恶意利用也是多么的容易。

那么，后面如果有志于更加深入的探索`ECC`的世界，应该从哪里开始呢？

首先，我们以及了解了质素域上的`Weierstrass`椭圆曲线，但是你必须知道还有其它类型的曲线和域，特别是以下几种：

- 二元域上面的`Koblitz`曲线：它们是形如![[公式]](https://www.zhihu.com/equation?tex=y%5E2%2Bxy%3Dx%5E3%2Bax%5E2%2B1)（其中![[公式]](https://www.zhihu.com/equation?tex=a)是0或1）定义在包含![[公式]](https://www.zhihu.com/equation?tex=2%5Em)（其中![[公式]](https://www.zhihu.com/equation?tex=m)是质数）个元素的有限域上的椭圆曲线。它们可以实现特别高效的点加和标量乘法。标准化的 `Koblitz`曲线有`nistk163`,`nistk283`,`nistk571`（这三条曲线分别定义在 163, 283 和 571 位的域上）
- 二元曲线：这类曲线与`Koblitz`曲线类似，它们是形如![[公式]](https://www.zhihu.com/equation?tex=x%5E2%2Bxy%3Dx%5E3%2Bx%5E2%2Bb)（其中![[公式]](https://www.zhihu.com/equation?tex=b)是整数，通常来源于一个随机数种子）。顾名思义，二元曲线被限制在二元域上。标准化的二元曲线有`nistb163`, `nistb283` 和 `nistb571`。 必须要说明的是, 有越来越多的担忧认为 `Koblitz` 曲线和二元曲线可能并没有质数曲线那么安全
- `Edwards`曲线：它们形如![[公式]](https://www.zhihu.com/equation?tex=x%5E2%2By%5E2%3D1%2Bdx%5E2y%5E2)（其中![[公式]](https://www.zhihu.com/equation?tex=d)是0或1）。它们特别有趣，不仅在于点加法和标量乘法特别快，而且计算点加的公式在任何情况下（![[公式]](https://www.zhihu.com/equation?tex=P+%5Cne+Q%2C+P+%3D+Q%2C+P+%3D+-Q)）都是一样的。该特性充分考虑了旁路攻击的可能性，即当你在测量标量乘法所耗费的时间以后用这个计算所耗费的时间来猜测标量参数的一种攻击方式。`Edwards`相对较新（2007年出现），目前尚未有`Certicom`或`NIST`之类的权威机构对其进行标准化
- `Curve25519`和 `Ed25519` 是两种分别为`ECDH` 和`ECDSA` 的某种变体特别设计的椭圆曲线。 和 `Edwards` 曲线一样, 这两种曲线也很快速并且能够抵御旁路攻击。也和 `Edwards` 曲线一样, 这两种曲线也尚未被标准化所以我们不能在流行软件中看到它们的身影（除了 `OpenSSH`, 它从 2014 年起支持了 `Ed25519` 密钥对）

如果你对 `ECC` 的实现细节感兴趣, 那么我建议你阅读 `OpenSSL` 和 `GnuTLS` 的源码。

最后，如果你对数学细节感兴趣，而不是算法的安全性和有效性，你必须知道：

- 椭圆曲线是亏格（genus）为 1 的代数变体
- 无限远处的点的概念来源于影射几何（projective geometry） 并可以通过齐次坐标（homogeneous coordinates）来表现 （尽管椭圆曲线并不需要影射几何中的绝大部分特性）

更别忘记研究有限域（finite fields）和场理论（field theory）。

如果对这些主体感兴趣，可以通过上面的这些关键字去了解。

现在这个系列文章就正式结束了，感谢大家的阅读，下次再见！



## 参考：

* **[知乎Datacruiser](https://www.zhihu.com/column/datacruiser)**

## 参考资料

- **[Elliptic Curve Cryptography: a gentle introduction](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction)**
- **[wiki百科-群](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%BE%A4)**
- **[区块链理论与方法](https://link.zhihu.com/?target=https%3A//item.jd.com/12782144.html)**
- **[wiki百科-椭圆曲线](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF)**
- **[Elliptic_Curve](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Elliptic_curve)**

- **[扩展欧几里德算法（Extended Euclidean algorithm）](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Extended_Euclidean_algorithm)**
- **[模运算（modular arithmetic）](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Modular_arithmetic)**
- **[Khan Academy](https://link.zhihu.com/?target=https%3A//www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic)**
- **[Elliptic Curve Cryptography: finite fields and discrete logarithms](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/)**
- **[有限域和离散对数问题(ECC椭圆曲线算法2)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/mrpre/article/details/72850598)**

- **[Elliptic Curve Cryptography: ECDH and ECDSA](https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/)**
- **[Diffie-Hellman algorithm](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)**
- **[数字签名算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Digital_Signature_Algorithm)**
- **[密码级安全的哈希函数](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cryptographic_hash_function)**
- **[sony公司犯过的一个错误](https://link.zhihu.com/?target=https%3A//www.bbc.com/news/technology-12116051)**